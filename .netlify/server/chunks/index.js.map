{"version":3,"file":"index.js","sources":["../../../../node_modules/esm-env/node.js","../../../../node_modules/svelte/src/internal/shared/utils.js","../../../../node_modules/svelte/src/internal/client/constants.js","../../../../node_modules/svelte/src/internal/client/errors.js","../../../../node_modules/svelte/src/internal/flags/index.js","../../../../node_modules/svelte/src/constants.js","../../../../node_modules/svelte/src/internal/client/dom/operations.js","../../../../node_modules/svelte/src/internal/client/reactivity/deriveds.js","../../../../node_modules/svelte/src/internal/client/reactivity/effects.js","../../../../node_modules/svelte/src/internal/client/dom/task.js","../../../../node_modules/svelte/src/internal/shared/errors.js","../../../../node_modules/svelte/src/internal/client/runtime.js","../../../../node_modules/svelte/src/escaping.js","../../../../node_modules/svelte/src/utils.js","../../../../node_modules/svelte/src/internal/shared/attributes.js","../../../../node_modules/svelte/src/store/utils.js","../../../../node_modules/svelte/src/internal/server/context.js","../../../../node_modules/svelte/src/internal/server/hydration.js","../../../../node_modules/svelte/src/internal/server/index.js"],"sourcesContent":["export const BROWSER = false;\nexport const DEV = false;\nexport const NODE = true;\n","// Store the references to globals in case someone tries to monkey patch these, causing the below\n// to de-opt (this occurs often when using popular extensions).\nexport var is_array = Array.isArray;\nexport var array_from = Array.from;\nexport var object_keys = Object.keys;\nexport var define_property = Object.defineProperty;\nexport var get_descriptor = Object.getOwnPropertyDescriptor;\nexport var get_descriptors = Object.getOwnPropertyDescriptors;\nexport var object_prototype = Object.prototype;\nexport var array_prototype = Array.prototype;\nexport var get_prototype_of = Object.getPrototypeOf;\n\n/**\n * @param {any} thing\n * @returns {thing is Function}\n */\nexport function is_function(thing) {\n\treturn typeof thing === 'function';\n}\n\nexport const noop = () => {};\n\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\n\n/**\n * @template [T=any]\n * @param {any} value\n * @returns {value is PromiseLike<T>}\n */\nexport function is_promise(value) {\n\treturn typeof value?.then === 'function';\n}\n\n/** @param {Function} fn */\nexport function run(fn) {\n\treturn fn();\n}\n\n/** @param {Array<() => void>} arr */\nexport function run_all(arr) {\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tarr[i]();\n\t}\n}\n\n/**\n * @template V\n * @param {V} value\n * @param {V | (() => V)} fallback\n * @param {boolean} [lazy]\n * @returns {V}\n */\nexport function fallback(value, fallback, lazy = false) {\n\treturn value === undefined\n\t\t? lazy\n\t\t\t? /** @type {() => V} */ (fallback)()\n\t\t\t: /** @type {V} */ (fallback)\n\t\t: value;\n}\n","export const DERIVED = 1 << 1;\nexport const EFFECT = 1 << 2;\nexport const RENDER_EFFECT = 1 << 3;\nexport const BLOCK_EFFECT = 1 << 4;\nexport const BRANCH_EFFECT = 1 << 5;\nexport const ROOT_EFFECT = 1 << 6;\nexport const UNOWNED = 1 << 7;\nexport const DISCONNECTED = 1 << 8;\nexport const CLEAN = 1 << 9;\nexport const DIRTY = 1 << 10;\nexport const MAYBE_DIRTY = 1 << 11;\nexport const INERT = 1 << 12;\nexport const DESTROYED = 1 << 13;\nexport const EFFECT_RAN = 1 << 14;\n/** 'Transparent' effects do not create a transition boundary */\nexport const EFFECT_TRANSPARENT = 1 << 15;\n/** Svelte 4 legacy mode props need to be handled with deriveds and be recognized elsewhere, hence the dedicated flag */\nexport const LEGACY_DERIVED_PROP = 1 << 16;\nexport const INSPECT_EFFECT = 1 << 17;\nexport const HEAD_EFFECT = 1 << 18;\nexport const EFFECT_HAS_DERIVED = 1 << 19;\n\nexport const STATE_SYMBOL = Symbol('$state');\nexport const STATE_SYMBOL_METADATA = Symbol('$state metadata');\nexport const LEGACY_PROPS = Symbol('legacy props');\nexport const LOADING_ATTR_SYMBOL = Symbol('');\n","/* This file is generated by scripts/process-messages/index.js. Do not edit! */\n\nimport { DEV } from 'esm-env';\n\n/**\n * Using `bind:value` together with a checkbox input is not allowed. Use `bind:checked` instead\n * @returns {never}\n */\nexport function bind_invalid_checkbox_value() {\n\tif (DEV) {\n\t\tconst error = new Error(`bind_invalid_checkbox_value\\nUsing \\`bind:value\\` together with a checkbox input is not allowed. Use \\`bind:checked\\` instead`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"bind_invalid_checkbox_value\");\n\t}\n}\n\n/**\n * Component %component% has an export named `%key%` that a consumer component is trying to access using `bind:%key%`, which is disallowed. Instead, use `bind:this` (e.g. `<%name% bind:this={component} />`) and then access the property on the bound component instance (e.g. `component.%key%`)\n * @param {string} component\n * @param {string} key\n * @param {string} name\n * @returns {never}\n */\nexport function bind_invalid_export(component, key, name) {\n\tif (DEV) {\n\t\tconst error = new Error(`bind_invalid_export\\nComponent ${component} has an export named \\`${key}\\` that a consumer component is trying to access using \\`bind:${key}\\`, which is disallowed. Instead, use \\`bind:this\\` (e.g. \\`<${name} bind:this={component} />\\`) and then access the property on the bound component instance (e.g. \\`component.${key}\\`)`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"bind_invalid_export\");\n\t}\n}\n\n/**\n * A component is attempting to bind to a non-bindable property `%key%` belonging to %component% (i.e. `<%name% bind:%key%={...}>`). To mark a property as bindable: `let { %key% = $bindable() } = $props()`\n * @param {string} key\n * @param {string} component\n * @param {string} name\n * @returns {never}\n */\nexport function bind_not_bindable(key, component, name) {\n\tif (DEV) {\n\t\tconst error = new Error(`bind_not_bindable\\nA component is attempting to bind to a non-bindable property \\`${key}\\` belonging to ${component} (i.e. \\`<${name} bind:${key}={...}>\\`). To mark a property as bindable: \\`let { ${key} = $bindable() } = $props()\\``);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"bind_not_bindable\");\n\t}\n}\n\n/**\n * %parent% called `%method%` on an instance of %component%, which is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information\n * @param {string} parent\n * @param {string} method\n * @param {string} component\n * @returns {never}\n */\nexport function component_api_changed(parent, method, component) {\n\tif (DEV) {\n\t\tconst error = new Error(`component_api_changed\\n${parent} called \\`${method}\\` on an instance of ${component}, which is no longer valid in Svelte 5. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"component_api_changed\");\n\t}\n}\n\n/**\n * Attempted to instantiate %component% with `new %name%`, which is no longer valid in Svelte 5. If this component is not under your control, set the `compatibility.componentApi` compiler option to `4` to keep it working. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information\n * @param {string} component\n * @param {string} name\n * @returns {never}\n */\nexport function component_api_invalid_new(component, name) {\n\tif (DEV) {\n\t\tconst error = new Error(`component_api_invalid_new\\nAttempted to instantiate ${component} with \\`new ${name}\\`, which is no longer valid in Svelte 5. If this component is not under your control, set the \\`compatibility.componentApi\\` compiler option to \\`4\\` to keep it working. See https://svelte.dev/docs/svelte/v5-migration-guide#Components-are-no-longer-classes for more information`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"component_api_invalid_new\");\n\t}\n}\n\n/**\n * A derived value cannot reference itself recursively\n * @returns {never}\n */\nexport function derived_references_self() {\n\tif (DEV) {\n\t\tconst error = new Error(`derived_references_self\\nA derived value cannot reference itself recursively`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"derived_references_self\");\n\t}\n}\n\n/**\n * Keyed each block has duplicate key `%value%` at indexes %a% and %b%\n * @param {string} a\n * @param {string} b\n * @param {string | undefined | null} [value]\n * @returns {never}\n */\nexport function each_key_duplicate(a, b, value) {\n\tif (DEV) {\n\t\tconst error = new Error(`each_key_duplicate\\n${value ? `Keyed each block has duplicate key \\`${value}\\` at indexes ${a} and ${b}` : `Keyed each block has duplicate key at indexes ${a} and ${b}`}`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"each_key_duplicate\");\n\t}\n}\n\n/**\n * `%rune%` cannot be used inside an effect cleanup function\n * @param {string} rune\n * @returns {never}\n */\nexport function effect_in_teardown(rune) {\n\tif (DEV) {\n\t\tconst error = new Error(`effect_in_teardown\\n\\`${rune}\\` cannot be used inside an effect cleanup function`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"effect_in_teardown\");\n\t}\n}\n\n/**\n * Effect cannot be created inside a `$derived` value that was not itself created inside an effect\n * @returns {never}\n */\nexport function effect_in_unowned_derived() {\n\tif (DEV) {\n\t\tconst error = new Error(`effect_in_unowned_derived\\nEffect cannot be created inside a \\`$derived\\` value that was not itself created inside an effect`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"effect_in_unowned_derived\");\n\t}\n}\n\n/**\n * `%rune%` can only be used inside an effect (e.g. during component initialisation)\n * @param {string} rune\n * @returns {never}\n */\nexport function effect_orphan(rune) {\n\tif (DEV) {\n\t\tconst error = new Error(`effect_orphan\\n\\`${rune}\\` can only be used inside an effect (e.g. during component initialisation)`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"effect_orphan\");\n\t}\n}\n\n/**\n * Maximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops\n * @returns {never}\n */\nexport function effect_update_depth_exceeded() {\n\tif (DEV) {\n\t\tconst error = new Error(`effect_update_depth_exceeded\\nMaximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"effect_update_depth_exceeded\");\n\t}\n}\n\n/**\n * Failed to hydrate the application\n * @returns {never}\n */\nexport function hydration_failed() {\n\tif (DEV) {\n\t\tconst error = new Error(`hydration_failed\\nFailed to hydrate the application`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"hydration_failed\");\n\t}\n}\n\n/**\n * Could not `{@render}` snippet due to the expression being `null` or `undefined`. Consider using optional chaining `{@render snippet?.()}`\n * @returns {never}\n */\nexport function invalid_snippet() {\n\tif (DEV) {\n\t\tconst error = new Error(`invalid_snippet\\nCould not \\`{@render}\\` snippet due to the expression being \\`null\\` or \\`undefined\\`. Consider using optional chaining \\`{@render snippet?.()}\\``);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"invalid_snippet\");\n\t}\n}\n\n/**\n * `%name%(...)` cannot be used in runes mode\n * @param {string} name\n * @returns {never}\n */\nexport function lifecycle_legacy_only(name) {\n\tif (DEV) {\n\t\tconst error = new Error(`lifecycle_legacy_only\\n\\`${name}(...)\\` cannot be used in runes mode`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"lifecycle_legacy_only\");\n\t}\n}\n\n/**\n * Cannot do `bind:%key%={undefined}` when `%key%` has a fallback value\n * @param {string} key\n * @returns {never}\n */\nexport function props_invalid_value(key) {\n\tif (DEV) {\n\t\tconst error = new Error(`props_invalid_value\\nCannot do \\`bind:${key}={undefined}\\` when \\`${key}\\` has a fallback value`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"props_invalid_value\");\n\t}\n}\n\n/**\n * Rest element properties of `$props()` such as `%property%` are readonly\n * @param {string} property\n * @returns {never}\n */\nexport function props_rest_readonly(property) {\n\tif (DEV) {\n\t\tconst error = new Error(`props_rest_readonly\\nRest element properties of \\`$props()\\` such as \\`${property}\\` are readonly`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"props_rest_readonly\");\n\t}\n}\n\n/**\n * The `%rune%` rune is only available inside `.svelte` and `.svelte.js/ts` files\n * @param {string} rune\n * @returns {never}\n */\nexport function rune_outside_svelte(rune) {\n\tif (DEV) {\n\t\tconst error = new Error(`rune_outside_svelte\\nThe \\`${rune}\\` rune is only available inside \\`.svelte\\` and \\`.svelte.js/ts\\` files`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"rune_outside_svelte\");\n\t}\n}\n\n/**\n * Property descriptors defined on `$state` objects must contain `value` and always be `enumerable`, `configurable` and `writable`.\n * @returns {never}\n */\nexport function state_descriptors_fixed() {\n\tif (DEV) {\n\t\tconst error = new Error(`state_descriptors_fixed\\nProperty descriptors defined on \\`$state\\` objects must contain \\`value\\` and always be \\`enumerable\\`, \\`configurable\\` and \\`writable\\`.`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"state_descriptors_fixed\");\n\t}\n}\n\n/**\n * Cannot set prototype of `$state` object\n * @returns {never}\n */\nexport function state_prototype_fixed() {\n\tif (DEV) {\n\t\tconst error = new Error(`state_prototype_fixed\\nCannot set prototype of \\`$state\\` object`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"state_prototype_fixed\");\n\t}\n}\n\n/**\n * Reading state that was created inside the same derived is forbidden. Consider using `untrack` to read locally created state\n * @returns {never}\n */\nexport function state_unsafe_local_read() {\n\tif (DEV) {\n\t\tconst error = new Error(`state_unsafe_local_read\\nReading state that was created inside the same derived is forbidden. Consider using \\`untrack\\` to read locally created state`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"state_unsafe_local_read\");\n\t}\n}\n\n/**\n * Updating state inside a derived or a template expression is forbidden. If the value should not be reactive, declare it without `$state`\n * @returns {never}\n */\nexport function state_unsafe_mutation() {\n\tif (DEV) {\n\t\tconst error = new Error(`state_unsafe_mutation\\nUpdating state inside a derived or a template expression is forbidden. If the value should not be reactive, declare it without \\`$state\\``);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"state_unsafe_mutation\");\n\t}\n}","export let legacy_mode_flag = false;\n\nexport function enable_legacy_mode_flag() {\n\tlegacy_mode_flag = true;\n}\n","export const EACH_ITEM_REACTIVE = 1;\nexport const EACH_INDEX_REACTIVE = 1 << 1;\n/** See EachBlock interface metadata.is_controlled for an explanation what this is */\nexport const EACH_IS_CONTROLLED = 1 << 2;\nexport const EACH_IS_ANIMATED = 1 << 3;\nexport const EACH_ITEM_IMMUTABLE = 1 << 4;\n\nexport const PROPS_IS_IMMUTABLE = 1;\nexport const PROPS_IS_RUNES = 1 << 1;\nexport const PROPS_IS_UPDATED = 1 << 2;\nexport const PROPS_IS_BINDABLE = 1 << 3;\nexport const PROPS_IS_LAZY_INITIAL = 1 << 4;\n\nexport const TRANSITION_IN = 1;\nexport const TRANSITION_OUT = 1 << 1;\nexport const TRANSITION_GLOBAL = 1 << 2;\n\nexport const TEMPLATE_FRAGMENT = 1;\nexport const TEMPLATE_USE_IMPORT_NODE = 1 << 1;\n\nexport const HYDRATION_START = '[';\n/** used to indicate that an `{:else}...` block was rendered */\nexport const HYDRATION_START_ELSE = '[!';\nexport const HYDRATION_END = ']';\nexport const HYDRATION_ERROR = {};\n\nexport const ELEMENT_IS_NAMESPACED = 1;\nexport const ELEMENT_PRESERVE_ATTRIBUTE_CASE = 1 << 1;\n\nexport const UNINITIALIZED = Symbol();\n\n// Dev-time component properties\nexport const FILENAME = Symbol('filename');\nexport const HMR = Symbol('hmr');\n\nexport const NAMESPACE_SVG = 'http://www.w3.org/2000/svg';\nexport const NAMESPACE_MATHML = 'http://www.w3.org/1998/Math/MathML';\n\n// we use a list of ignorable runtime warnings because not every runtime warning\n// can be ignored and we want to keep the validation for svelte-ignore in place\nexport const IGNORABLE_RUNTIME_WARNINGS = /** @type {const} */ ([\n\t'state_snapshot_uncloneable',\n\t'binding_property_non_reactive',\n\t'hydration_attribute_changed',\n\t'hydration_html_changed',\n\t'ownership_invalid_binding',\n\t'ownership_invalid_mutation'\n]);\n\n/**\n * Whitespace inside one of these elements will not result in\n * a whitespace node being created in any circumstances. (This\n * list is almost certainly very incomplete)\n * TODO this is currently unused\n */\nexport const ELEMENTS_WITHOUT_TEXT = ['audio', 'datalist', 'dl', 'optgroup', 'select', 'video'];\n","/** @import { TemplateNode } from '#client' */\nimport { hydrate_node, hydrating, set_hydrate_node } from './hydration.js';\nimport { DEV } from 'esm-env';\nimport { init_array_prototype_warnings } from '../dev/equality.js';\nimport { get_descriptor } from '../../shared/utils.js';\n\n// export these for reference in the compiled code, making global name deduplication unnecessary\n/** @type {Window} */\nexport var $window;\n\n/** @type {Document} */\nexport var $document;\n\n/** @type {() => Node | null} */\nvar first_child_getter;\n/** @type {() => Node | null} */\nvar next_sibling_getter;\n\n/**\n * Initialize these lazily to avoid issues when using the runtime in a server context\n * where these globals are not available while avoiding a separate server entry point\n */\nexport function init_operations() {\n\tif ($window !== undefined) {\n\t\treturn;\n\t}\n\n\t$window = window;\n\t$document = document;\n\n\tvar element_prototype = Element.prototype;\n\tvar node_prototype = Node.prototype;\n\n\t// @ts-ignore\n\tfirst_child_getter = get_descriptor(node_prototype, 'firstChild').get;\n\t// @ts-ignore\n\tnext_sibling_getter = get_descriptor(node_prototype, 'nextSibling').get;\n\n\t// the following assignments improve perf of lookups on DOM nodes\n\t// @ts-expect-error\n\telement_prototype.__click = undefined;\n\t// @ts-expect-error\n\telement_prototype.__className = '';\n\t// @ts-expect-error\n\telement_prototype.__attributes = null;\n\t// @ts-expect-error\n\telement_prototype.__styles = null;\n\t// @ts-expect-error\n\telement_prototype.__e = undefined;\n\n\t// @ts-expect-error\n\tText.prototype.__t = undefined;\n\n\tif (DEV) {\n\t\t// @ts-expect-error\n\t\telement_prototype.__svelte_meta = null;\n\n\t\tinit_array_prototype_warnings();\n\t}\n}\n\n/**\n * @param {string} value\n * @returns {Text}\n */\nexport function create_text(value = '') {\n\treturn document.createTextNode(value);\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @returns {Node | null}\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function get_first_child(node) {\n\treturn first_child_getter.call(node);\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @returns {Node | null}\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function get_next_sibling(node) {\n\treturn next_sibling_getter.call(node);\n}\n\n/**\n * Don't mark this as side-effect-free, hydration needs to walk all nodes\n * @template {Node} N\n * @param {N} node\n * @param {boolean} is_text\n * @returns {Node | null}\n */\nexport function child(node, is_text) {\n\tif (!hydrating) {\n\t\treturn get_first_child(node);\n\t}\n\n\tvar child = /** @type {TemplateNode} */ (get_first_child(hydrate_node));\n\n\t// Child can be null if we have an element with a single child, like `<p>{text}</p>`, where `text` is empty\n\tif (child === null) {\n\t\tchild = hydrate_node.appendChild(create_text());\n\t} else if (is_text && child.nodeType !== 3) {\n\t\tvar text = create_text();\n\t\tchild?.before(text);\n\t\tset_hydrate_node(text);\n\t\treturn text;\n\t}\n\n\tset_hydrate_node(child);\n\treturn child;\n}\n\n/**\n * Don't mark this as side-effect-free, hydration needs to walk all nodes\n * @param {DocumentFragment | TemplateNode[]} fragment\n * @param {boolean} is_text\n * @returns {Node | null}\n */\nexport function first_child(fragment, is_text) {\n\tif (!hydrating) {\n\t\t// when not hydrating, `fragment` is a `DocumentFragment` (the result of calling `open_frag`)\n\t\tvar first = /** @type {DocumentFragment} */ (get_first_child(/** @type {Node} */ (fragment)));\n\n\t\t// TODO prevent user comments with the empty string when preserveComments is true\n\t\tif (first instanceof Comment && first.data === '') return get_next_sibling(first);\n\n\t\treturn first;\n\t}\n\n\t// if an {expression} is empty during SSR, there might be no\n\t// text node to hydrate — we must therefore create one\n\tif (is_text && hydrate_node?.nodeType !== 3) {\n\t\tvar text = create_text();\n\n\t\thydrate_node?.before(text);\n\t\tset_hydrate_node(text);\n\t\treturn text;\n\t}\n\n\treturn hydrate_node;\n}\n\n/**\n * Don't mark this as side-effect-free, hydration needs to walk all nodes\n * @param {TemplateNode} node\n * @param {number} count\n * @param {boolean} is_text\n * @returns {Node | null}\n */\nexport function sibling(node, count = 1, is_text = false) {\n\tlet next_sibling = hydrating ? hydrate_node : node;\n\n\twhile (count--) {\n\t\tnext_sibling = /** @type {TemplateNode} */ (get_next_sibling(next_sibling));\n\t}\n\n\tif (!hydrating) {\n\t\treturn next_sibling;\n\t}\n\n\tvar type = next_sibling.nodeType;\n\n\t// if a sibling {expression} is empty during SSR, there might be no\n\t// text node to hydrate — we must therefore create one\n\tif (is_text && type !== 3) {\n\t\tvar text = create_text();\n\t\tnext_sibling?.before(text);\n\t\tset_hydrate_node(text);\n\t\treturn text;\n\t}\n\n\tset_hydrate_node(next_sibling);\n\treturn /** @type {TemplateNode} */ (next_sibling);\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @returns {void}\n */\nexport function clear_text_content(node) {\n\tnode.textContent = '';\n}\n","/** @import { Derived, Effect } from '#client' */\nimport { DEV } from 'esm-env';\nimport {\n\tCLEAN,\n\tDERIVED,\n\tDESTROYED,\n\tDIRTY,\n\tEFFECT_HAS_DERIVED,\n\tMAYBE_DIRTY,\n\tUNOWNED\n} from '../constants.js';\nimport {\n\tactive_reaction,\n\tactive_effect,\n\tremove_reactions,\n\tset_signal_status,\n\tskip_reaction,\n\tupdate_reaction,\n\tincrement_version,\n\tset_active_effect,\n\tcomponent_context\n} from '../runtime.js';\nimport { equals, safe_equals } from './equality.js';\nimport * as e from '../errors.js';\nimport { destroy_effect } from './effects.js';\nimport { inspect_effects, set_inspect_effects } from './sources.js';\n\n/**\n * @template V\n * @param {() => V} fn\n * @returns {Derived<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function derived(fn) {\n\tvar flags = DERIVED | DIRTY;\n\n\tif (active_effect === null) {\n\t\tflags |= UNOWNED;\n\t} else {\n\t\t// Since deriveds are evaluated lazily, any effects created inside them are\n\t\t// created too late to ensure that the parent effect is added to the tree\n\t\tactive_effect.f |= EFFECT_HAS_DERIVED;\n\t}\n\n\t/** @type {Derived<V>} */\n\tconst signal = {\n\t\tchildren: null,\n\t\tctx: component_context,\n\t\tdeps: null,\n\t\tequals,\n\t\tf: flags,\n\t\tfn,\n\t\treactions: null,\n\t\tv: /** @type {V} */ (null),\n\t\tversion: 0,\n\t\tparent: active_effect\n\t};\n\n\tif (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {\n\t\tvar derived = /** @type {Derived} */ (active_reaction);\n\t\t(derived.children ??= []).push(signal);\n\t}\n\n\treturn signal;\n}\n\n/**\n * @template V\n * @param {() => V} fn\n * @returns {Derived<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function derived_safe_equal(fn) {\n\tconst signal = derived(fn);\n\tsignal.equals = safe_equals;\n\treturn signal;\n}\n\n/**\n * @param {Derived} derived\n * @returns {void}\n */\nfunction destroy_derived_children(derived) {\n\tvar children = derived.children;\n\n\tif (children !== null) {\n\t\tderived.children = null;\n\n\t\tfor (var i = 0; i < children.length; i += 1) {\n\t\t\tvar child = children[i];\n\t\t\tif ((child.f & DERIVED) !== 0) {\n\t\t\t\tdestroy_derived(/** @type {Derived} */ (child));\n\t\t\t} else {\n\t\t\t\tdestroy_effect(/** @type {Effect} */ (child));\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * The currently updating deriveds, used to detect infinite recursion\n * in dev mode and provide a nicer error than 'too much recursion'\n * @type {Derived[]}\n */\nlet stack = [];\n\n/**\n * @template T\n * @param {Derived} derived\n * @returns {T}\n */\nexport function execute_derived(derived) {\n\tvar value;\n\tvar prev_active_effect = active_effect;\n\n\tset_active_effect(derived.parent);\n\n\tif (DEV) {\n\t\tlet prev_inspect_effects = inspect_effects;\n\t\tset_inspect_effects(new Set());\n\t\ttry {\n\t\t\tif (stack.includes(derived)) {\n\t\t\t\te.derived_references_self();\n\t\t\t}\n\n\t\t\tstack.push(derived);\n\n\t\t\tdestroy_derived_children(derived);\n\t\t\tvalue = update_reaction(derived);\n\t\t} finally {\n\t\t\tset_active_effect(prev_active_effect);\n\t\t\tset_inspect_effects(prev_inspect_effects);\n\t\t\tstack.pop();\n\t\t}\n\t} else {\n\t\ttry {\n\t\t\tdestroy_derived_children(derived);\n\t\t\tvalue = update_reaction(derived);\n\t\t} finally {\n\t\t\tset_active_effect(prev_active_effect);\n\t\t}\n\t}\n\n\treturn value;\n}\n\n/**\n * @param {Derived} derived\n * @returns {void}\n */\nexport function update_derived(derived) {\n\tvar value = execute_derived(derived);\n\tvar status =\n\t\t(skip_reaction || (derived.f & UNOWNED) !== 0) && derived.deps !== null ? MAYBE_DIRTY : CLEAN;\n\n\tset_signal_status(derived, status);\n\n\tif (!derived.equals(value)) {\n\t\tderived.v = value;\n\t\tderived.version = increment_version();\n\t}\n}\n\n/**\n * @param {Derived} signal\n * @returns {void}\n */\nexport function destroy_derived(signal) {\n\tdestroy_derived_children(signal);\n\tremove_reactions(signal, 0);\n\tset_signal_status(signal, DESTROYED);\n\n\t// TODO we need to ensure we remove the derived from any parent derives\n\tsignal.v = signal.children = signal.deps = signal.ctx = signal.reactions = null;\n}\n","/** @import { ComponentContext, ComponentContextLegacy, Derived, Effect, Reaction, TemplateNode, TransitionManager } from '#client' */\nimport {\n\tcheck_dirtiness,\n\tcomponent_context,\n\tactive_effect,\n\tactive_reaction,\n\tdev_current_component_function,\n\tupdate_effect,\n\tget,\n\tis_destroying_effect,\n\tis_flushing_effect,\n\tremove_reactions,\n\tschedule_effect,\n\tset_active_reaction,\n\tset_is_destroying_effect,\n\tset_is_flushing_effect,\n\tset_signal_status,\n\tuntrack,\n\tskip_reaction\n} from '../runtime.js';\nimport {\n\tDIRTY,\n\tBRANCH_EFFECT,\n\tRENDER_EFFECT,\n\tEFFECT,\n\tDESTROYED,\n\tINERT,\n\tEFFECT_RAN,\n\tBLOCK_EFFECT,\n\tROOT_EFFECT,\n\tEFFECT_TRANSPARENT,\n\tDERIVED,\n\tUNOWNED,\n\tCLEAN,\n\tINSPECT_EFFECT,\n\tHEAD_EFFECT,\n\tMAYBE_DIRTY,\n\tEFFECT_HAS_DERIVED\n} from '../constants.js';\nimport { set } from './sources.js';\nimport * as e from '../errors.js';\nimport { DEV } from 'esm-env';\nimport { define_property } from '../../shared/utils.js';\nimport { get_next_sibling } from '../dom/operations.js';\nimport { destroy_derived } from './deriveds.js';\n\n/**\n * @param {'$effect' | '$effect.pre' | '$inspect'} rune\n */\nexport function validate_effect(rune) {\n\tif (active_effect === null && active_reaction === null) {\n\t\te.effect_orphan(rune);\n\t}\n\n\tif (active_reaction !== null && (active_reaction.f & UNOWNED) !== 0) {\n\t\te.effect_in_unowned_derived();\n\t}\n\n\tif (is_destroying_effect) {\n\t\te.effect_in_teardown(rune);\n\t}\n}\n\n/**\n * @param {Effect} effect\n * @param {Effect} parent_effect\n */\nfunction push_effect(effect, parent_effect) {\n\tvar parent_last = parent_effect.last;\n\tif (parent_last === null) {\n\t\tparent_effect.last = parent_effect.first = effect;\n\t} else {\n\t\tparent_last.next = effect;\n\t\teffect.prev = parent_last;\n\t\tparent_effect.last = effect;\n\t}\n}\n\n/**\n * @param {number} type\n * @param {null | (() => void | (() => void))} fn\n * @param {boolean} sync\n * @param {boolean} push\n * @returns {Effect}\n */\nfunction create_effect(type, fn, sync, push = true) {\n\tvar is_root = (type & ROOT_EFFECT) !== 0;\n\tvar parent_effect = active_effect;\n\n\tif (DEV) {\n\t\t// Ensure the parent is never an inspect effect\n\t\twhile (parent_effect !== null && (parent_effect.f & INSPECT_EFFECT) !== 0) {\n\t\t\tparent_effect = parent_effect.parent;\n\t\t}\n\t}\n\n\t/** @type {Effect} */\n\tvar effect = {\n\t\tctx: component_context,\n\t\tdeps: null,\n\t\tderiveds: null,\n\t\tnodes_start: null,\n\t\tnodes_end: null,\n\t\tf: type | DIRTY,\n\t\tfirst: null,\n\t\tfn,\n\t\tlast: null,\n\t\tnext: null,\n\t\tparent: is_root ? null : parent_effect,\n\t\tprev: null,\n\t\tteardown: null,\n\t\ttransitions: null,\n\t\tversion: 0\n\t};\n\n\tif (DEV) {\n\t\teffect.component_function = dev_current_component_function;\n\t}\n\n\tif (sync) {\n\t\tvar previously_flushing_effect = is_flushing_effect;\n\n\t\ttry {\n\t\t\tset_is_flushing_effect(true);\n\t\t\tupdate_effect(effect);\n\t\t\teffect.f |= EFFECT_RAN;\n\t\t} catch (e) {\n\t\t\tdestroy_effect(effect);\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tset_is_flushing_effect(previously_flushing_effect);\n\t\t}\n\t} else if (fn !== null) {\n\t\tschedule_effect(effect);\n\t}\n\n\t// if an effect has no dependencies, no DOM and no teardown function,\n\t// don't bother adding it to the effect tree\n\tvar inert =\n\t\tsync &&\n\t\teffect.deps === null &&\n\t\teffect.first === null &&\n\t\teffect.nodes_start === null &&\n\t\teffect.teardown === null &&\n\t\t(effect.f & EFFECT_HAS_DERIVED) === 0;\n\n\tif (!inert && !is_root && push) {\n\t\tif (parent_effect !== null) {\n\t\t\tpush_effect(effect, parent_effect);\n\t\t}\n\n\t\t// if we're in a derived, add the effect there too\n\t\tif (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {\n\t\t\tvar derived = /** @type {Derived} */ (active_reaction);\n\t\t\t(derived.children ??= []).push(effect);\n\t\t}\n\t}\n\n\treturn effect;\n}\n\n/**\n * Internal representation of `$effect.tracking()`\n * @returns {boolean}\n */\nexport function effect_tracking() {\n\tif (active_reaction === null) {\n\t\treturn false;\n\t}\n\n\t// If it's skipped, that's because we're inside an unowned\n\t// that is not being tracked by another reaction\n\treturn !skip_reaction;\n}\n\n/**\n * @param {() => void} fn\n */\nexport function teardown(fn) {\n\tconst effect = create_effect(RENDER_EFFECT, null, false);\n\tset_signal_status(effect, CLEAN);\n\teffect.teardown = fn;\n\treturn effect;\n}\n\n/**\n * Internal representation of `$effect(...)`\n * @param {() => void | (() => void)} fn\n */\nexport function user_effect(fn) {\n\tvalidate_effect('$effect');\n\n\t// Non-nested `$effect(...)` in a component should be deferred\n\t// until the component is mounted\n\tvar defer =\n\t\tactive_effect !== null &&\n\t\t(active_effect.f & BRANCH_EFFECT) !== 0 &&\n\t\tcomponent_context !== null &&\n\t\t!component_context.m;\n\n\tif (DEV) {\n\t\tdefine_property(fn, 'name', {\n\t\t\tvalue: '$effect'\n\t\t});\n\t}\n\n\tif (defer) {\n\t\tvar context = /** @type {ComponentContext} */ (component_context);\n\t\t(context.e ??= []).push({\n\t\t\tfn,\n\t\t\teffect: active_effect,\n\t\t\treaction: active_reaction\n\t\t});\n\t} else {\n\t\tvar signal = effect(fn);\n\t\treturn signal;\n\t}\n}\n\n/**\n * Internal representation of `$effect.pre(...)`\n * @param {() => void | (() => void)} fn\n * @returns {Effect}\n */\nexport function user_pre_effect(fn) {\n\tvalidate_effect('$effect.pre');\n\tif (DEV) {\n\t\tdefine_property(fn, 'name', {\n\t\t\tvalue: '$effect.pre'\n\t\t});\n\t}\n\treturn render_effect(fn);\n}\n\n/** @param {() => void | (() => void)} fn */\nexport function inspect_effect(fn) {\n\treturn create_effect(INSPECT_EFFECT, fn, true);\n}\n\n/**\n * Internal representation of `$effect.root(...)`\n * @param {() => void | (() => void)} fn\n * @returns {() => void}\n */\nexport function effect_root(fn) {\n\tconst effect = create_effect(ROOT_EFFECT, fn, true);\n\treturn () => {\n\t\tdestroy_effect(effect);\n\t};\n}\n\n/**\n * @param {() => void | (() => void)} fn\n * @returns {Effect}\n */\nexport function effect(fn) {\n\treturn create_effect(EFFECT, fn, false);\n}\n\n/**\n * Internal representation of `$: ..`\n * @param {() => any} deps\n * @param {() => void | (() => void)} fn\n */\nexport function legacy_pre_effect(deps, fn) {\n\tvar context = /** @type {ComponentContextLegacy} */ (component_context);\n\n\t/** @type {{ effect: null | Effect, ran: boolean }} */\n\tvar token = { effect: null, ran: false };\n\tcontext.l.r1.push(token);\n\n\ttoken.effect = render_effect(() => {\n\t\tdeps();\n\n\t\t// If this legacy pre effect has already run before the end of the reset, then\n\t\t// bail out to emulate the same behavior.\n\t\tif (token.ran) return;\n\n\t\ttoken.ran = true;\n\t\tset(context.l.r2, true);\n\t\tuntrack(fn);\n\t});\n}\n\nexport function legacy_pre_effect_reset() {\n\tvar context = /** @type {ComponentContextLegacy} */ (component_context);\n\n\trender_effect(() => {\n\t\tif (!get(context.l.r2)) return;\n\n\t\t// Run dirty `$:` statements\n\t\tfor (var token of context.l.r1) {\n\t\t\tvar effect = token.effect;\n\n\t\t\t// If the effect is CLEAN, then make it MAYBE_DIRTY. This ensures we traverse through\n\t\t\t// the effects dependencies and correctly ensure each dependency is up-to-date.\n\t\t\tif ((effect.f & CLEAN) !== 0) {\n\t\t\t\tset_signal_status(effect, MAYBE_DIRTY);\n\t\t\t}\n\n\t\t\tif (check_dirtiness(effect)) {\n\t\t\t\tupdate_effect(effect);\n\t\t\t}\n\n\t\t\ttoken.ran = false;\n\t\t}\n\n\t\tcontext.l.r2.v = false; // set directly to avoid rerunning this effect\n\t});\n}\n\n/**\n * @param {() => void | (() => void)} fn\n * @returns {Effect}\n */\nexport function render_effect(fn) {\n\treturn create_effect(RENDER_EFFECT, fn, true);\n}\n\n/**\n * @param {() => void | (() => void)} fn\n * @returns {Effect}\n */\nexport function template_effect(fn) {\n\tif (DEV) {\n\t\tdefine_property(fn, 'name', {\n\t\t\tvalue: '{expression}'\n\t\t});\n\t}\n\treturn block(fn);\n}\n\n/**\n * @param {(() => void)} fn\n * @param {number} flags\n */\nexport function block(fn, flags = 0) {\n\treturn create_effect(RENDER_EFFECT | BLOCK_EFFECT | flags, fn, true);\n}\n\n/**\n * @param {(() => void)} fn\n * @param {boolean} [push]\n */\nexport function branch(fn, push = true) {\n\treturn create_effect(RENDER_EFFECT | BRANCH_EFFECT, fn, true, push);\n}\n\n/**\n * @param {Effect} effect\n */\nexport function execute_effect_teardown(effect) {\n\tvar teardown = effect.teardown;\n\tif (teardown !== null) {\n\t\tconst previously_destroying_effect = is_destroying_effect;\n\t\tconst previous_reaction = active_reaction;\n\t\tset_is_destroying_effect(true);\n\t\tset_active_reaction(null);\n\t\ttry {\n\t\t\tteardown.call(null);\n\t\t} finally {\n\t\t\tset_is_destroying_effect(previously_destroying_effect);\n\t\t\tset_active_reaction(previous_reaction);\n\t\t}\n\t}\n}\n\n/**\n * @param {Effect} signal\n * @returns {void}\n */\nexport function destroy_effect_deriveds(signal) {\n\tvar deriveds = signal.deriveds;\n\n\tif (deriveds !== null) {\n\t\tsignal.deriveds = null;\n\n\t\tfor (var i = 0; i < deriveds.length; i += 1) {\n\t\t\tdestroy_derived(deriveds[i]);\n\t\t}\n\t}\n}\n\n/**\n * @param {Effect} signal\n * @param {boolean} remove_dom\n * @returns {void}\n */\nexport function destroy_effect_children(signal, remove_dom = false) {\n\tvar effect = signal.first;\n\tsignal.first = signal.last = null;\n\n\twhile (effect !== null) {\n\t\tvar next = effect.next;\n\t\tdestroy_effect(effect, remove_dom);\n\t\teffect = next;\n\t}\n}\n\n/**\n * @param {Effect} signal\n * @returns {void}\n */\nexport function destroy_block_effect_children(signal) {\n\tvar effect = signal.first;\n\n\twhile (effect !== null) {\n\t\tvar next = effect.next;\n\t\tif ((effect.f & BRANCH_EFFECT) === 0) {\n\t\t\tdestroy_effect(effect);\n\t\t}\n\t\teffect = next;\n\t}\n}\n\n/**\n * @param {Effect} effect\n * @param {boolean} [remove_dom]\n * @returns {void}\n */\nexport function destroy_effect(effect, remove_dom = true) {\n\tvar removed = false;\n\n\tif ((remove_dom || (effect.f & HEAD_EFFECT) !== 0) && effect.nodes_start !== null) {\n\t\t/** @type {TemplateNode | null} */\n\t\tvar node = effect.nodes_start;\n\t\tvar end = effect.nodes_end;\n\n\t\twhile (node !== null) {\n\t\t\t/** @type {TemplateNode | null} */\n\t\t\tvar next = node === end ? null : /** @type {TemplateNode} */ (get_next_sibling(node));\n\n\t\t\tnode.remove();\n\t\t\tnode = next;\n\t\t}\n\n\t\tremoved = true;\n\t}\n\n\tdestroy_effect_children(effect, remove_dom && !removed);\n\tdestroy_effect_deriveds(effect);\n\tremove_reactions(effect, 0);\n\tset_signal_status(effect, DESTROYED);\n\n\tvar transitions = effect.transitions;\n\n\tif (transitions !== null) {\n\t\tfor (const transition of transitions) {\n\t\t\ttransition.stop();\n\t\t}\n\t}\n\n\texecute_effect_teardown(effect);\n\n\tvar parent = effect.parent;\n\n\t// If the parent doesn't have any children, then skip this work altogether\n\tif (parent !== null && parent.first !== null) {\n\t\tunlink_effect(effect);\n\t}\n\n\tif (DEV) {\n\t\teffect.component_function = null;\n\t}\n\n\t// `first` and `child` are nulled out in destroy_effect_children\n\teffect.next =\n\t\teffect.prev =\n\t\teffect.teardown =\n\t\teffect.ctx =\n\t\teffect.deps =\n\t\teffect.parent =\n\t\teffect.fn =\n\t\teffect.nodes_start =\n\t\teffect.nodes_end =\n\t\t\tnull;\n}\n\n/**\n * Detach an effect from the effect tree, freeing up memory and\n * reducing the amount of work that happens on subsequent traversals\n * @param {Effect} effect\n */\nexport function unlink_effect(effect) {\n\tvar parent = effect.parent;\n\tvar prev = effect.prev;\n\tvar next = effect.next;\n\n\tif (prev !== null) prev.next = next;\n\tif (next !== null) next.prev = prev;\n\n\tif (parent !== null) {\n\t\tif (parent.first === effect) parent.first = next;\n\t\tif (parent.last === effect) parent.last = prev;\n\t}\n}\n\n/**\n * When a block effect is removed, we don't immediately destroy it or yank it\n * out of the DOM, because it might have transitions. Instead, we 'pause' it.\n * It stays around (in memory, and in the DOM) until outro transitions have\n * completed, and if the state change is reversed then we _resume_ it.\n * A paused effect does not update, and the DOM subtree becomes inert.\n * @param {Effect} effect\n * @param {() => void} [callback]\n */\nexport function pause_effect(effect, callback) {\n\t/** @type {TransitionManager[]} */\n\tvar transitions = [];\n\n\tpause_children(effect, transitions, true);\n\n\trun_out_transitions(transitions, () => {\n\t\tdestroy_effect(effect);\n\t\tif (callback) callback();\n\t});\n}\n\n/**\n * @param {TransitionManager[]} transitions\n * @param {() => void} fn\n */\nexport function run_out_transitions(transitions, fn) {\n\tvar remaining = transitions.length;\n\tif (remaining > 0) {\n\t\tvar check = () => --remaining || fn();\n\t\tfor (var transition of transitions) {\n\t\t\ttransition.out(check);\n\t\t}\n\t} else {\n\t\tfn();\n\t}\n}\n\n/**\n * @param {Effect} effect\n * @param {TransitionManager[]} transitions\n * @param {boolean} local\n */\nexport function pause_children(effect, transitions, local) {\n\tif ((effect.f & INERT) !== 0) return;\n\teffect.f ^= INERT;\n\n\tif (effect.transitions !== null) {\n\t\tfor (const transition of effect.transitions) {\n\t\t\tif (transition.is_global || local) {\n\t\t\t\ttransitions.push(transition);\n\t\t\t}\n\t\t}\n\t}\n\n\tvar child = effect.first;\n\n\twhile (child !== null) {\n\t\tvar sibling = child.next;\n\t\tvar transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;\n\t\t// TODO we don't need to call pause_children recursively with a linked list in place\n\t\t// it's slightly more involved though as we have to account for `transparent` changing\n\t\t// through the tree.\n\t\tpause_children(child, transitions, transparent ? local : false);\n\t\tchild = sibling;\n\t}\n}\n\n/**\n * The opposite of `pause_effect`. We call this if (for example)\n * `x` becomes falsy then truthy: `{#if x}...{/if}`\n * @param {Effect} effect\n */\nexport function resume_effect(effect) {\n\tresume_children(effect, true);\n}\n\n/**\n * @param {Effect} effect\n * @param {boolean} local\n */\nfunction resume_children(effect, local) {\n\tif ((effect.f & INERT) === 0) return;\n\n\t// If a dependency of this effect changed while it was paused,\n\t// apply the change now\n\tif (check_dirtiness(effect)) {\n\t\tupdate_effect(effect);\n\t}\n\n\t// Ensure we toggle the flag after possibly updating the effect so that\n\t// each block logic can correctly operate on inert items\n\teffect.f ^= INERT;\n\n\tvar child = effect.first;\n\n\twhile (child !== null) {\n\t\tvar sibling = child.next;\n\t\tvar transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;\n\t\t// TODO we don't need to call resume_children recursively with a linked list in place\n\t\t// it's slightly more involved though as we have to account for `transparent` changing\n\t\t// through the tree.\n\t\tresume_children(child, transparent ? local : false);\n\t\tchild = sibling;\n\t}\n\n\tif (effect.transitions !== null) {\n\t\tfor (const transition of effect.transitions) {\n\t\t\tif (transition.is_global || local) {\n\t\t\t\ttransition.in();\n\t\t\t}\n\t\t}\n\t}\n}\n","import { run_all } from '../../shared/utils.js';\n\n// Fallback for when requestIdleCallback is not available\nconst request_idle_callback =\n\ttypeof requestIdleCallback === 'undefined'\n\t\t? (/** @type {() => void} */ cb) => setTimeout(cb, 1)\n\t\t: requestIdleCallback;\n\nlet is_micro_task_queued = false;\nlet is_idle_task_queued = false;\n\n/** @type {Array<() => void>} */\nlet current_queued_micro_tasks = [];\n/** @type {Array<() => void>} */\nlet current_queued_idle_tasks = [];\n\nfunction process_micro_tasks() {\n\tis_micro_task_queued = false;\n\tconst tasks = current_queued_micro_tasks.slice();\n\tcurrent_queued_micro_tasks = [];\n\trun_all(tasks);\n}\n\nfunction process_idle_tasks() {\n\tis_idle_task_queued = false;\n\tconst tasks = current_queued_idle_tasks.slice();\n\tcurrent_queued_idle_tasks = [];\n\trun_all(tasks);\n}\n\n/**\n * @param {() => void} fn\n */\nexport function queue_micro_task(fn) {\n\tif (!is_micro_task_queued) {\n\t\tis_micro_task_queued = true;\n\t\tqueueMicrotask(process_micro_tasks);\n\t}\n\tcurrent_queued_micro_tasks.push(fn);\n}\n\n/**\n * @param {() => void} fn\n */\nexport function queue_idle_task(fn) {\n\tif (!is_idle_task_queued) {\n\t\tis_idle_task_queued = true;\n\t\trequest_idle_callback(process_idle_tasks);\n\t}\n\tcurrent_queued_idle_tasks.push(fn);\n}\n\n/**\n * Synchronously run any queued tasks.\n */\nexport function flush_tasks() {\n\tif (is_micro_task_queued) {\n\t\tprocess_micro_tasks();\n\t}\n\tif (is_idle_task_queued) {\n\t\tprocess_idle_tasks();\n\t}\n}\n","/* This file is generated by scripts/process-messages/index.js. Do not edit! */\n\nimport { DEV } from 'esm-env';\n\n/**\n * Cannot use `{@render children(...)}` if the parent component uses `let:` directives. Consider using a named snippet instead\n * @returns {never}\n */\nexport function invalid_default_snippet() {\n\tif (DEV) {\n\t\tconst error = new Error(`invalid_default_snippet\\nCannot use \\`{@render children(...)}\\` if the parent component uses \\`let:\\` directives. Consider using a named snippet instead`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"invalid_default_snippet\");\n\t}\n}\n\n/**\n * `%name%(...)` can only be used during component initialisation\n * @param {string} name\n * @returns {never}\n */\nexport function lifecycle_outside_component(name) {\n\tif (DEV) {\n\t\tconst error = new Error(`lifecycle_outside_component\\n\\`${name}(...)\\` can only be used during component initialisation`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"lifecycle_outside_component\");\n\t}\n}\n\n/**\n * `%name%` is not a store with a `subscribe` method\n * @param {string} name\n * @returns {never}\n */\nexport function store_invalid_shape(name) {\n\tif (DEV) {\n\t\tconst error = new Error(`store_invalid_shape\\n\\`${name}\\` is not a store with a \\`subscribe\\` method`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"store_invalid_shape\");\n\t}\n}\n\n/**\n * The `this` prop on `<svelte:element>` must be a string, if defined\n * @returns {never}\n */\nexport function svelte_element_invalid_this_value() {\n\tif (DEV) {\n\t\tconst error = new Error(`svelte_element_invalid_this_value\\nThe \\`this\\` prop on \\`<svelte:element>\\` must be a string, if defined`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"svelte_element_invalid_this_value\");\n\t}\n}","/** @import { ComponentContext, Derived, Effect, Reaction, Signal, Source, Value } from '#client' */\nimport { DEV } from 'esm-env';\nimport { define_property, get_descriptors, get_prototype_of } from '../shared/utils.js';\nimport {\n\tdestroy_block_effect_children,\n\tdestroy_effect_children,\n\tdestroy_effect_deriveds,\n\teffect,\n\texecute_effect_teardown,\n\tunlink_effect\n} from './reactivity/effects.js';\nimport {\n\tEFFECT,\n\tRENDER_EFFECT,\n\tDIRTY,\n\tMAYBE_DIRTY,\n\tCLEAN,\n\tDERIVED,\n\tUNOWNED,\n\tDESTROYED,\n\tINERT,\n\tBRANCH_EFFECT,\n\tSTATE_SYMBOL,\n\tBLOCK_EFFECT,\n\tROOT_EFFECT,\n\tLEGACY_DERIVED_PROP,\n\tDISCONNECTED\n} from './constants.js';\nimport { flush_tasks } from './dom/task.js';\nimport { add_owner } from './dev/ownership.js';\nimport { mutate, set, source } from './reactivity/sources.js';\nimport { destroy_derived, execute_derived, update_derived } from './reactivity/deriveds.js';\nimport * as e from './errors.js';\nimport { lifecycle_outside_component } from '../shared/errors.js';\nimport { FILENAME } from '../../constants.js';\nimport { legacy_mode_flag } from '../flags/index.js';\n\nconst FLUSH_MICROTASK = 0;\nconst FLUSH_SYNC = 1;\n\n// Used for DEV time error handling\n/** @param {WeakSet<Error>} value */\nconst handled_errors = new WeakSet();\n// Used for controlling the flush of effects.\nlet scheduler_mode = FLUSH_MICROTASK;\n// Used for handling scheduling\nlet is_micro_task_queued = false;\n\nexport let is_flushing_effect = false;\nexport let is_destroying_effect = false;\n\n/** @param {boolean} value */\nexport function set_is_flushing_effect(value) {\n\tis_flushing_effect = value;\n}\n\n/** @param {boolean} value */\nexport function set_is_destroying_effect(value) {\n\tis_destroying_effect = value;\n}\n\n// Handle effect queues\n\n/** @type {Effect[]} */\nlet queued_root_effects = [];\n\nlet flush_count = 0;\n/** @type {Effect[]} Stack of effects, dev only */\nlet dev_effect_stack = [];\n// Handle signal reactivity tree dependencies and reactions\n\n/** @type {null | Reaction} */\nexport let active_reaction = null;\n\n/** @param {null | Reaction} reaction */\nexport function set_active_reaction(reaction) {\n\tactive_reaction = reaction;\n}\n\n/** @type {null | Effect} */\nexport let active_effect = null;\n\n/** @param {null | Effect} effect */\nexport function set_active_effect(effect) {\n\tactive_effect = effect;\n}\n\n/**\n * When sources are created within a derived, we record them so that we can safely allow\n * local mutations to these sources without the side-effect error being invoked unnecessarily.\n * @type {null | Source[]}\n */\nexport let derived_sources = null;\n\n/**\n * @param {Source[] | null} sources\n */\nexport function set_derived_sources(sources) {\n\tderived_sources = sources;\n}\n\n/**\n * The dependencies of the reaction that is currently being executed. In many cases,\n * the dependencies are unchanged between runs, and so this will be `null` unless\n * and until a new dependency is accessed — we track this via `skipped_deps`\n * @type {null | Value[]}\n */\nexport let new_deps = null;\n\nlet skipped_deps = 0;\n\n/**\n * Tracks writes that the effect it's executed in doesn't listen to yet,\n * so that the dependency can be added to the effect later on if it then reads it\n * @type {null | Source[]}\n */\nexport let untracked_writes = null;\n\n/** @param {null | Source[]} value */\nexport function set_untracked_writes(value) {\n\tuntracked_writes = value;\n}\n\n/** @type {number} Used by sources and deriveds for handling updates to unowned deriveds */\nlet current_version = 0;\n\n// If we are working with a get() chain that has no active container,\n// to prevent memory leaks, we skip adding the reaction.\nexport let skip_reaction = false;\n// Handle collecting all signals which are read during a specific time frame\n/** @type {Set<Value> | null} */\nexport let captured_signals = null;\n\n// Handling runtime component context\n/** @type {ComponentContext | null} */\nexport let component_context = null;\n\n/** @param {ComponentContext | null} context */\nexport function set_component_context(context) {\n\tcomponent_context = context;\n}\n\n/**\n * The current component function. Different from current component context:\n * ```html\n * <!-- App.svelte -->\n * <Foo>\n *   <Bar /> <!-- context == Foo.svelte, function == App.svelte -->\n * </Foo>\n * ```\n * @type {ComponentContext['function']}\n */\nexport let dev_current_component_function = null;\n\n/** @param {ComponentContext['function']} fn */\nexport function set_dev_current_component_function(fn) {\n\tdev_current_component_function = fn;\n}\n\nexport function increment_version() {\n\treturn ++current_version;\n}\n\n/** @returns {boolean} */\nexport function is_runes() {\n\treturn !legacy_mode_flag || (component_context !== null && component_context.l === null);\n}\n\n/**\n * Determines whether a derived or effect is dirty.\n * If it is MAYBE_DIRTY, will set the status to CLEAN\n * @param {Reaction} reaction\n * @returns {boolean}\n */\nexport function check_dirtiness(reaction) {\n\tvar flags = reaction.f;\n\n\tif ((flags & DIRTY) !== 0) {\n\t\treturn true;\n\t}\n\n\tif ((flags & MAYBE_DIRTY) !== 0) {\n\t\tvar dependencies = reaction.deps;\n\t\tvar is_unowned = (flags & UNOWNED) !== 0;\n\n\t\tif (dependencies !== null) {\n\t\t\tvar i;\n\n\t\t\tif ((flags & DISCONNECTED) !== 0) {\n\t\t\t\tfor (i = 0; i < dependencies.length; i++) {\n\t\t\t\t\t(dependencies[i].reactions ??= []).push(reaction);\n\t\t\t\t}\n\n\t\t\t\treaction.f ^= DISCONNECTED;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < dependencies.length; i++) {\n\t\t\t\tvar dependency = dependencies[i];\n\n\t\t\t\tif (check_dirtiness(/** @type {Derived} */ (dependency))) {\n\t\t\t\t\tupdate_derived(/** @type {Derived} */ (dependency));\n\t\t\t\t}\n\n\t\t\t\t// If we are working with an unowned signal as part of an effect (due to !skip_reaction)\n\t\t\t\t// and the version hasn't changed, we still need to check that this reaction\n\t\t\t\t// is linked to the dependency source – otherwise future updates will not be caught.\n\t\t\t\tif (\n\t\t\t\t\tis_unowned &&\n\t\t\t\t\tactive_effect !== null &&\n\t\t\t\t\t!skip_reaction &&\n\t\t\t\t\t!dependency?.reactions?.includes(reaction)\n\t\t\t\t) {\n\t\t\t\t\t(dependency.reactions ??= []).push(reaction);\n\t\t\t\t}\n\n\t\t\t\tif (dependency.version > reaction.version) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Unowned signals should never be marked as clean.\n\t\tif (!is_unowned) {\n\t\t\tset_signal_status(reaction, CLEAN);\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * @param {Error} error\n * @param {Effect} effect\n * @param {ComponentContext | null} component_context\n */\nfunction handle_error(error, effect, component_context) {\n\t// Given we don't yet have error boundaries, we will just always throw.\n\tif (!DEV || handled_errors.has(error) || component_context === null) {\n\t\tthrow error;\n\t}\n\n\tconst component_stack = [];\n\n\tconst effect_name = effect.fn?.name;\n\n\tif (effect_name) {\n\t\tcomponent_stack.push(effect_name);\n\t}\n\n\t/** @type {ComponentContext | null} */\n\tlet current_context = component_context;\n\n\twhile (current_context !== null) {\n\t\tif (DEV) {\n\t\t\t/** @type {string} */\n\t\t\tvar filename = current_context.function?.[FILENAME];\n\n\t\t\tif (filename) {\n\t\t\t\tconst file = filename.split('/').pop();\n\t\t\t\tcomponent_stack.push(file);\n\t\t\t}\n\t\t}\n\n\t\tcurrent_context = current_context.p;\n\t}\n\n\tconst indent = /Firefox/.test(navigator.userAgent) ? '  ' : '\\t';\n\tdefine_property(error, 'message', {\n\t\tvalue: error.message + `\\n${component_stack.map((name) => `\\n${indent}in ${name}`).join('')}\\n`\n\t});\n\n\tconst stack = error.stack;\n\n\t// Filter out internal files from callstack\n\tif (stack) {\n\t\tconst lines = stack.split('\\n');\n\t\tconst new_lines = [];\n\t\tfor (let i = 0; i < lines.length; i++) {\n\t\t\tconst line = lines[i];\n\t\t\tif (line.includes('svelte/src/internal')) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnew_lines.push(line);\n\t\t}\n\t\tdefine_property(error, 'stack', {\n\t\t\tvalue: error.stack + new_lines.join('\\n')\n\t\t});\n\t}\n\n\thandled_errors.add(error);\n\tthrow error;\n}\n\n/**\n * @template V\n * @param {Reaction} reaction\n * @returns {V}\n */\nexport function update_reaction(reaction) {\n\tvar previous_deps = new_deps;\n\tvar previous_skipped_deps = skipped_deps;\n\tvar previous_untracked_writes = untracked_writes;\n\tvar previous_reaction = active_reaction;\n\tvar previous_skip_reaction = skip_reaction;\n\tvar prev_derived_sources = derived_sources;\n\tvar previous_component_context = component_context;\n\tvar flags = reaction.f;\n\n\tnew_deps = /** @type {null | Value[]} */ (null);\n\tskipped_deps = 0;\n\tuntracked_writes = null;\n\tactive_reaction = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;\n\tskip_reaction = !is_flushing_effect && (flags & UNOWNED) !== 0;\n\tderived_sources = null;\n\tcomponent_context = reaction.ctx;\n\n\ttry {\n\t\tvar result = /** @type {Function} */ (0, reaction.fn)();\n\t\tvar deps = reaction.deps;\n\n\t\tif (new_deps !== null) {\n\t\t\tvar i;\n\n\t\t\tremove_reactions(reaction, skipped_deps);\n\n\t\t\tif (deps !== null && skipped_deps > 0) {\n\t\t\t\tdeps.length = skipped_deps + new_deps.length;\n\t\t\t\tfor (i = 0; i < new_deps.length; i++) {\n\t\t\t\t\tdeps[skipped_deps + i] = new_deps[i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treaction.deps = deps = new_deps;\n\t\t\t}\n\n\t\t\tif (!skip_reaction) {\n\t\t\t\tfor (i = skipped_deps; i < deps.length; i++) {\n\t\t\t\t\t(deps[i].reactions ??= []).push(reaction);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (deps !== null && skipped_deps < deps.length) {\n\t\t\tremove_reactions(reaction, skipped_deps);\n\t\t\tdeps.length = skipped_deps;\n\t\t}\n\n\t\treturn result;\n\t} finally {\n\t\tnew_deps = previous_deps;\n\t\tskipped_deps = previous_skipped_deps;\n\t\tuntracked_writes = previous_untracked_writes;\n\t\tactive_reaction = previous_reaction;\n\t\tskip_reaction = previous_skip_reaction;\n\t\tderived_sources = prev_derived_sources;\n\t\tcomponent_context = previous_component_context;\n\t}\n}\n\n/**\n * @template V\n * @param {Reaction} signal\n * @param {Value<V>} dependency\n * @returns {void}\n */\nfunction remove_reaction(signal, dependency) {\n\tlet reactions = dependency.reactions;\n\tif (reactions !== null) {\n\t\tvar index = reactions.indexOf(signal);\n\t\tif (index !== -1) {\n\t\t\tvar new_length = reactions.length - 1;\n\t\t\tif (new_length === 0) {\n\t\t\t\treactions = dependency.reactions = null;\n\t\t\t} else {\n\t\t\t\t// Swap with last element and then remove.\n\t\t\t\treactions[index] = reactions[new_length];\n\t\t\t\treactions.pop();\n\t\t\t}\n\t\t}\n\t}\n\t// If the derived has no reactions, then we can disconnect it from the graph,\n\t// allowing it to either reconnect in the future, or be GC'd by the VM.\n\tif (\n\t\treactions === null &&\n\t\t(dependency.f & DERIVED) !== 0 &&\n\t\t// Destroying a child effect while updating a parent effect can cause a dependency to appear\n\t\t// to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`\n\t\t// allows us to skip the expensive work of disconnecting and immediately reconnecting it\n\t\t(new_deps === null || !new_deps.includes(dependency))\n\t) {\n\t\tset_signal_status(dependency, MAYBE_DIRTY);\n\t\t// If we are working with a derived that is owned by an effect, then mark it as being\n\t\t// disconnected.\n\t\tif ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {\n\t\t\tdependency.f ^= DISCONNECTED;\n\t\t}\n\t\tremove_reactions(/** @type {Derived} **/ (dependency), 0);\n\t}\n}\n\n/**\n * @param {Reaction} signal\n * @param {number} start_index\n * @returns {void}\n */\nexport function remove_reactions(signal, start_index) {\n\tvar dependencies = signal.deps;\n\tif (dependencies === null) return;\n\n\tfor (var i = start_index; i < dependencies.length; i++) {\n\t\tremove_reaction(signal, dependencies[i]);\n\t}\n}\n\n/**\n * @param {Effect} effect\n * @returns {void}\n */\nexport function update_effect(effect) {\n\tvar flags = effect.f;\n\n\tif ((flags & DESTROYED) !== 0) {\n\t\treturn;\n\t}\n\n\tset_signal_status(effect, CLEAN);\n\n\tvar previous_effect = active_effect;\n\tvar previous_component_context = component_context;\n\n\tactive_effect = effect;\n\n\tif (DEV) {\n\t\tvar previous_component_fn = dev_current_component_function;\n\t\tdev_current_component_function = effect.component_function;\n\t}\n\n\ttry {\n\t\tif ((flags & BLOCK_EFFECT) !== 0) {\n\t\t\tdestroy_block_effect_children(effect);\n\t\t} else {\n\t\t\tdestroy_effect_children(effect);\n\t\t}\n\t\tdestroy_effect_deriveds(effect);\n\n\t\texecute_effect_teardown(effect);\n\t\tvar teardown = update_reaction(effect);\n\t\teffect.teardown = typeof teardown === 'function' ? teardown : null;\n\t\teffect.version = current_version;\n\n\t\tif (DEV) {\n\t\t\tdev_effect_stack.push(effect);\n\t\t}\n\t} catch (error) {\n\t\thandle_error(/** @type {Error} */ (error), effect, previous_component_context);\n\t} finally {\n\t\tactive_effect = previous_effect;\n\n\t\tif (DEV) {\n\t\t\tdev_current_component_function = previous_component_fn;\n\t\t}\n\t}\n}\n\nfunction infinite_loop_guard() {\n\tif (flush_count > 1000) {\n\t\tflush_count = 0;\n\t\tif (DEV) {\n\t\t\ttry {\n\t\t\t\te.effect_update_depth_exceeded();\n\t\t\t} catch (error) {\n\t\t\t\t// stack is garbage, ignore. Instead add a console.error message.\n\t\t\t\tdefine_property(error, 'stack', {\n\t\t\t\t\tvalue: ''\n\t\t\t\t});\n\t\t\t\t// eslint-disable-next-line no-console\n\t\t\t\tconsole.error(\n\t\t\t\t\t'Last ten effects were: ',\n\t\t\t\t\tdev_effect_stack.slice(-10).map((d) => d.fn)\n\t\t\t\t);\n\t\t\t\tdev_effect_stack = [];\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t} else {\n\t\t\te.effect_update_depth_exceeded();\n\t\t}\n\t}\n\tflush_count++;\n}\n\n/**\n * @param {Array<Effect>} root_effects\n * @returns {void}\n */\nfunction flush_queued_root_effects(root_effects) {\n\tvar length = root_effects.length;\n\tif (length === 0) {\n\t\treturn;\n\t}\n\tinfinite_loop_guard();\n\n\tvar previously_flushing_effect = is_flushing_effect;\n\tis_flushing_effect = true;\n\n\ttry {\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tvar effect = root_effects[i];\n\n\t\t\tif ((effect.f & CLEAN) === 0) {\n\t\t\t\teffect.f ^= CLEAN;\n\t\t\t}\n\n\t\t\t/** @type {Effect[]} */\n\t\t\tvar collected_effects = [];\n\n\t\t\tprocess_effects(effect, collected_effects);\n\t\t\tflush_queued_effects(collected_effects);\n\t\t}\n\t} finally {\n\t\tis_flushing_effect = previously_flushing_effect;\n\t}\n}\n\n/**\n * @param {Array<Effect>} effects\n * @returns {void}\n */\nfunction flush_queued_effects(effects) {\n\tvar length = effects.length;\n\tif (length === 0) return;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar effect = effects[i];\n\n\t\tif ((effect.f & (DESTROYED | INERT)) === 0 && check_dirtiness(effect)) {\n\t\t\tupdate_effect(effect);\n\n\t\t\t// Effects with no dependencies or teardown do not get added to the effect tree.\n\t\t\t// Deferred effects (e.g. `$effect(...)`) _are_ added to the tree because we\n\t\t\t// don't know if we need to keep them until they are executed. Doing the check\n\t\t\t// here (rather than in `update_effect`) allows us to skip the work for\n\t\t\t// immediate effects.\n\t\t\tif (effect.deps === null && effect.first === null && effect.nodes_start === null) {\n\t\t\t\tif (effect.teardown === null) {\n\t\t\t\t\t// remove this effect from the graph\n\t\t\t\t\tunlink_effect(effect);\n\t\t\t\t} else {\n\t\t\t\t\t// keep the effect in the graph, but free up some memory\n\t\t\t\t\teffect.fn = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction process_deferred() {\n\tis_micro_task_queued = false;\n\tif (flush_count > 1001) {\n\t\treturn;\n\t}\n\tconst previous_queued_root_effects = queued_root_effects;\n\tqueued_root_effects = [];\n\tflush_queued_root_effects(previous_queued_root_effects);\n\tif (!is_micro_task_queued) {\n\t\tflush_count = 0;\n\t\tif (DEV) {\n\t\t\tdev_effect_stack = [];\n\t\t}\n\t}\n}\n\n/**\n * @param {Effect} signal\n * @returns {void}\n */\nexport function schedule_effect(signal) {\n\tif (scheduler_mode === FLUSH_MICROTASK) {\n\t\tif (!is_micro_task_queued) {\n\t\t\tis_micro_task_queued = true;\n\t\t\tqueueMicrotask(process_deferred);\n\t\t}\n\t}\n\n\tvar effect = signal;\n\n\twhile (effect.parent !== null) {\n\t\teffect = effect.parent;\n\t\tvar flags = effect.f;\n\n\t\tif ((flags & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {\n\t\t\tif ((flags & CLEAN) === 0) return;\n\t\t\teffect.f ^= CLEAN;\n\t\t}\n\t}\n\n\tqueued_root_effects.push(effect);\n}\n\n/**\n *\n * This function both runs render effects and collects user effects in topological order\n * from the starting effect passed in. Effects will be collected when they match the filtered\n * bitwise flag passed in only. The collected effects array will be populated with all the user\n * effects to be flushed.\n *\n * @param {Effect} effect\n * @param {Effect[]} collected_effects\n * @returns {void}\n */\nfunction process_effects(effect, collected_effects) {\n\tvar current_effect = effect.first;\n\tvar effects = [];\n\n\tmain_loop: while (current_effect !== null) {\n\t\tvar flags = current_effect.f;\n\t\tvar is_branch = (flags & BRANCH_EFFECT) !== 0;\n\t\tvar is_skippable_branch = is_branch && (flags & CLEAN) !== 0;\n\n\t\tif (!is_skippable_branch && (flags & INERT) === 0) {\n\t\t\tif ((flags & RENDER_EFFECT) !== 0) {\n\t\t\t\tif (is_branch) {\n\t\t\t\t\tcurrent_effect.f ^= CLEAN;\n\t\t\t\t} else if (check_dirtiness(current_effect)) {\n\t\t\t\t\tupdate_effect(current_effect);\n\t\t\t\t}\n\n\t\t\t\tvar child = current_effect.first;\n\n\t\t\t\tif (child !== null) {\n\t\t\t\t\tcurrent_effect = child;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if ((flags & EFFECT) !== 0) {\n\t\t\t\teffects.push(current_effect);\n\t\t\t}\n\t\t}\n\n\t\tvar sibling = current_effect.next;\n\n\t\tif (sibling === null) {\n\t\t\tlet parent = current_effect.parent;\n\n\t\t\twhile (parent !== null) {\n\t\t\t\tif (effect === parent) {\n\t\t\t\t\tbreak main_loop;\n\t\t\t\t}\n\t\t\t\tvar parent_sibling = parent.next;\n\t\t\t\tif (parent_sibling !== null) {\n\t\t\t\t\tcurrent_effect = parent_sibling;\n\t\t\t\t\tcontinue main_loop;\n\t\t\t\t}\n\t\t\t\tparent = parent.parent;\n\t\t\t}\n\t\t}\n\n\t\tcurrent_effect = sibling;\n\t}\n\n\t// We might be dealing with many effects here, far more than can be spread into\n\t// an array push call (callstack overflow). So let's deal with each effect in a loop.\n\tfor (var i = 0; i < effects.length; i++) {\n\t\tchild = effects[i];\n\t\tcollected_effects.push(child);\n\t\tprocess_effects(child, collected_effects);\n\t}\n}\n\n/**\n * Internal version of `flushSync` with the option to not flush previous effects.\n * Returns the result of the passed function, if given.\n * @param {() => any} [fn]\n * @returns {any}\n */\nexport function flush_sync(fn) {\n\tvar previous_scheduler_mode = scheduler_mode;\n\tvar previous_queued_root_effects = queued_root_effects;\n\n\ttry {\n\t\tinfinite_loop_guard();\n\n\t\t/** @type {Effect[]} */\n\t\tconst root_effects = [];\n\n\t\tscheduler_mode = FLUSH_SYNC;\n\t\tqueued_root_effects = root_effects;\n\t\tis_micro_task_queued = false;\n\n\t\tflush_queued_root_effects(previous_queued_root_effects);\n\n\t\tvar result = fn?.();\n\n\t\tflush_tasks();\n\t\tif (queued_root_effects.length > 0 || root_effects.length > 0) {\n\t\t\tflush_sync();\n\t\t}\n\n\t\tflush_count = 0;\n\t\tif (DEV) {\n\t\t\tdev_effect_stack = [];\n\t\t}\n\n\t\treturn result;\n\t} finally {\n\t\tscheduler_mode = previous_scheduler_mode;\n\t\tqueued_root_effects = previous_queued_root_effects;\n\t}\n}\n\n/**\n * Returns a promise that resolves once any pending state changes have been applied.\n * @returns {Promise<void>}\n */\nexport async function tick() {\n\tawait Promise.resolve();\n\t// By calling flush_sync we guarantee that any pending state changes are applied after one tick.\n\t// TODO look into whether we can make flushing subsequent updates synchronously in the future.\n\tflush_sync();\n}\n\n/**\n * @template V\n * @param {Value<V>} signal\n * @returns {V}\n */\nexport function get(signal) {\n\tvar flags = signal.f;\n\tvar is_derived = (flags & DERIVED) !== 0;\n\n\t// If the derived is destroyed, just execute it again without retaining\n\t// its memoisation properties as the derived is stale\n\tif (is_derived && (flags & DESTROYED) !== 0) {\n\t\tvar value = execute_derived(/** @type {Derived} */ (signal));\n\t\t// Ensure the derived remains destroyed\n\t\tdestroy_derived(/** @type {Derived} */ (signal));\n\t\treturn value;\n\t}\n\n\tif (captured_signals !== null) {\n\t\tcaptured_signals.add(signal);\n\t}\n\n\t// Register the dependency on the current reaction signal.\n\tif (active_reaction !== null) {\n\t\tif (derived_sources !== null && derived_sources.includes(signal)) {\n\t\t\te.state_unsafe_local_read();\n\t\t}\n\t\tvar deps = active_reaction.deps;\n\n\t\t// If the signal is accessing the same dependencies in the same\n\t\t// order as it did last time, increment `skipped_deps`\n\t\t// rather than updating `new_deps`, which creates GC cost\n\t\tif (new_deps === null && deps !== null && deps[skipped_deps] === signal) {\n\t\t\tskipped_deps++;\n\t\t} else if (new_deps === null) {\n\t\t\tnew_deps = [signal];\n\t\t} else {\n\t\t\tnew_deps.push(signal);\n\t\t}\n\n\t\tif (\n\t\t\tuntracked_writes !== null &&\n\t\t\tactive_effect !== null &&\n\t\t\t(active_effect.f & CLEAN) !== 0 &&\n\t\t\t(active_effect.f & BRANCH_EFFECT) === 0 &&\n\t\t\tuntracked_writes.includes(signal)\n\t\t) {\n\t\t\tset_signal_status(active_effect, DIRTY);\n\t\t\tschedule_effect(active_effect);\n\t\t}\n\t} else if (is_derived && /** @type {Derived} */ (signal).deps === null) {\n\t\tvar derived = /** @type {Derived} */ (signal);\n\t\tvar parent = derived.parent;\n\n\t\tif (parent !== null && !parent.deriveds?.includes(derived)) {\n\t\t\t(parent.deriveds ??= []).push(derived);\n\t\t}\n\t}\n\n\tif (is_derived) {\n\t\tderived = /** @type {Derived} */ (signal);\n\n\t\tif (check_dirtiness(derived)) {\n\t\t\tupdate_derived(derived);\n\t\t}\n\t}\n\n\treturn signal.v;\n}\n\n/**\n * Like `get`, but checks for `undefined`. Used for `var` declarations because they can be accessed before being declared\n * @template V\n * @param {Value<V> | undefined} signal\n * @returns {V | undefined}\n */\nexport function safe_get(signal) {\n\treturn signal && get(signal);\n}\n\n/**\n * Invokes a function and captures all signals that are read during the invocation,\n * then invalidates them.\n * @param {() => any} fn\n */\nexport function invalidate_inner_signals(fn) {\n\tvar previous_captured_signals = captured_signals;\n\tcaptured_signals = new Set();\n\tvar captured = captured_signals;\n\tvar signal;\n\ttry {\n\t\tuntrack(fn);\n\t\tif (previous_captured_signals !== null) {\n\t\t\tfor (signal of captured_signals) {\n\t\t\t\tprevious_captured_signals.add(signal);\n\t\t\t}\n\t\t}\n\t} finally {\n\t\tcaptured_signals = previous_captured_signals;\n\t}\n\tfor (signal of captured) {\n\t\t// Go one level up because derived signals created as part of props in legacy mode\n\t\tif ((signal.f & LEGACY_DERIVED_PROP) !== 0) {\n\t\t\tfor (const dep of /** @type {Derived} */ (signal).deps || []) {\n\t\t\t\tif ((dep.f & DERIVED) === 0) {\n\t\t\t\t\tmutate(dep, null /* doesnt matter */);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tmutate(signal, null /* doesnt matter */);\n\t\t}\n\t}\n}\n\n/**\n * When used inside a [`$derived`](https://svelte.dev/docs/svelte/$derived) or [`$effect`](https://svelte.dev/docs/svelte/$effect),\n * any state read inside `fn` will not be treated as a dependency.\n *\n * ```ts\n * $effect(() => {\n *   // this will run when `data` changes, but not when `time` changes\n *   save(data, {\n *     timestamp: untrack(() => time)\n *   });\n * });\n * ```\n * @template T\n * @param {() => T} fn\n * @returns {T}\n */\nexport function untrack(fn) {\n\tconst previous_reaction = active_reaction;\n\ttry {\n\t\tactive_reaction = null;\n\t\treturn fn();\n\t} finally {\n\t\tactive_reaction = previous_reaction;\n\t}\n}\n\nconst STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);\n\n/**\n * @param {Signal} signal\n * @param {number} status\n * @returns {void}\n */\nexport function set_signal_status(signal, status) {\n\tsignal.f = (signal.f & STATUS_MASK) | status;\n}\n\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * @template T\n * @param {any} key\n * @returns {T}\n */\nexport function getContext(key) {\n\tconst context_map = get_or_init_context_map('getContext');\n\tconst result = /** @type {T} */ (context_map.get(key));\n\n\tif (DEV) {\n\t\tconst fn = /** @type {ComponentContext} */ (component_context).function;\n\t\tif (fn) {\n\t\t\tadd_owner(result, fn, true);\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * @template T\n * @param {any} key\n * @param {T} context\n * @returns {T}\n */\nexport function setContext(key, context) {\n\tconst context_map = get_or_init_context_map('setContext');\n\tcontext_map.set(key, context);\n\treturn context;\n}\n\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * @param {any} key\n * @returns {boolean}\n */\nexport function hasContext(key) {\n\tconst context_map = get_or_init_context_map('hasContext');\n\treturn context_map.has(key);\n}\n\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * @template {Map<any, any>} [T=Map<any, any>]\n * @returns {T}\n */\nexport function getAllContexts() {\n\tconst context_map = get_or_init_context_map('getAllContexts');\n\n\tif (DEV) {\n\t\tconst fn = component_context?.function;\n\t\tif (fn) {\n\t\t\tfor (const value of context_map.values()) {\n\t\t\t\tadd_owner(value, fn, true);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn /** @type {T} */ (context_map);\n}\n\n/**\n * @param {string} name\n * @returns {Map<unknown, unknown>}\n */\nfunction get_or_init_context_map(name) {\n\tif (component_context === null) {\n\t\tlifecycle_outside_component(name);\n\t}\n\n\treturn (component_context.c ??= new Map(get_parent_context(component_context) || undefined));\n}\n\n/**\n * @param {ComponentContext} component_context\n * @returns {Map<unknown, unknown> | null}\n */\nfunction get_parent_context(component_context) {\n\tlet parent = component_context.p;\n\twhile (parent !== null) {\n\t\tconst context_map = parent.c;\n\t\tif (context_map !== null) {\n\t\t\treturn context_map;\n\t\t}\n\t\tparent = parent.p;\n\t}\n\treturn null;\n}\n\n/**\n * @param {Value<number>} signal\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update(signal, d = 1) {\n\tvar value = +get(signal);\n\tset(signal, value + d);\n\treturn value;\n}\n\n/**\n * @param {Value<number>} signal\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre(signal, d = 1) {\n\treturn set(signal, +get(signal) + d);\n}\n\n/**\n * @param {Record<string, unknown>} obj\n * @param {string[]} keys\n * @returns {Record<string, unknown>}\n */\nexport function exclude_from_object(obj, keys) {\n\t/** @type {Record<string, unknown>} */\n\tvar result = {};\n\n\tfor (var key in obj) {\n\t\tif (!keys.includes(key)) {\n\t\t\tresult[key] = obj[key];\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * @param {Record<string, unknown>} props\n * @param {any} runes\n * @param {Function} [fn]\n * @returns {void}\n */\nexport function push(props, runes = false, fn) {\n\tcomponent_context = {\n\t\tp: component_context,\n\t\tc: null,\n\t\te: null,\n\t\tm: false,\n\t\ts: props,\n\t\tx: null,\n\t\tl: null\n\t};\n\n\tif (legacy_mode_flag && !runes) {\n\t\tcomponent_context.l = {\n\t\t\ts: null,\n\t\t\tu: null,\n\t\t\tr1: [],\n\t\t\tr2: source(false)\n\t\t};\n\t}\n\n\tif (DEV) {\n\t\t// component function\n\t\tcomponent_context.function = fn;\n\t\tdev_current_component_function = fn;\n\t}\n}\n\n/**\n * @template {Record<string, any>} T\n * @param {T} [component]\n * @returns {T}\n */\nexport function pop(component) {\n\tconst context_stack_item = component_context;\n\tif (context_stack_item !== null) {\n\t\tif (component !== undefined) {\n\t\t\tcontext_stack_item.x = component;\n\t\t}\n\t\tconst component_effects = context_stack_item.e;\n\t\tif (component_effects !== null) {\n\t\t\tvar previous_effect = active_effect;\n\t\t\tvar previous_reaction = active_reaction;\n\t\t\tcontext_stack_item.e = null;\n\t\t\ttry {\n\t\t\t\tfor (var i = 0; i < component_effects.length; i++) {\n\t\t\t\t\tvar component_effect = component_effects[i];\n\t\t\t\t\tset_active_effect(component_effect.effect);\n\t\t\t\t\tset_active_reaction(component_effect.reaction);\n\t\t\t\t\teffect(component_effect.fn);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tset_active_effect(previous_effect);\n\t\t\t\tset_active_reaction(previous_reaction);\n\t\t\t}\n\t\t}\n\t\tcomponent_context = context_stack_item.p;\n\t\tif (DEV) {\n\t\t\tdev_current_component_function = context_stack_item.p?.function ?? null;\n\t\t}\n\t\tcontext_stack_item.m = true;\n\t}\n\t// Micro-optimization: Don't set .a above to the empty object\n\t// so it can be garbage-collected when the return here is unused\n\treturn component || /** @type {T} */ ({});\n}\n\n/**\n * Possibly traverse an object and read all its properties so that they're all reactive in case this is `$state`.\n * Does only check first level of an object for performance reasons (heuristic should be good for 99% of all cases).\n * @param {any} value\n * @returns {void}\n */\nexport function deep_read_state(value) {\n\tif (typeof value !== 'object' || !value || value instanceof EventTarget) {\n\t\treturn;\n\t}\n\n\tif (STATE_SYMBOL in value) {\n\t\tdeep_read(value);\n\t} else if (!Array.isArray(value)) {\n\t\tfor (let key in value) {\n\t\t\tconst prop = value[key];\n\t\t\tif (typeof prop === 'object' && prop && STATE_SYMBOL in prop) {\n\t\t\t\tdeep_read(prop);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Deeply traverse an object and read all its properties\n * so that they're all reactive in case this is `$state`\n * @param {any} value\n * @param {Set<any>} visited\n * @returns {void}\n */\nexport function deep_read(value, visited = new Set()) {\n\tif (\n\t\ttypeof value === 'object' &&\n\t\tvalue !== null &&\n\t\t// We don't want to traverse DOM elements\n\t\t!(value instanceof EventTarget) &&\n\t\t!visited.has(value)\n\t) {\n\t\tvisited.add(value);\n\t\t// When working with a possible SvelteDate, this\n\t\t// will ensure we capture changes to it.\n\t\tif (value instanceof Date) {\n\t\t\tvalue.getTime();\n\t\t}\n\t\tfor (let key in value) {\n\t\t\ttry {\n\t\t\t\tdeep_read(value[key], visited);\n\t\t\t} catch (e) {\n\t\t\t\t// continue\n\t\t\t}\n\t\t}\n\t\tconst proto = get_prototype_of(value);\n\t\tif (\n\t\t\tproto !== Object.prototype &&\n\t\t\tproto !== Array.prototype &&\n\t\t\tproto !== Map.prototype &&\n\t\t\tproto !== Set.prototype &&\n\t\t\tproto !== Date.prototype\n\t\t) {\n\t\t\tconst descriptors = get_descriptors(proto);\n\t\t\tfor (let key in descriptors) {\n\t\t\t\tconst get = descriptors[key].get;\n\t\t\t\tif (get) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tget.call(value);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t// continue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nif (DEV) {\n\t/**\n\t * @param {string} rune\n\t */\n\tfunction throw_rune_error(rune) {\n\t\tif (!(rune in globalThis)) {\n\t\t\t// TODO if people start adjusting the \"this can contain runes\" config through v-p-s more, adjust this message\n\t\t\t/** @type {any} */\n\t\t\tlet value; // let's hope noone modifies this global, but belts and braces\n\t\t\tObject.defineProperty(globalThis, rune, {\n\t\t\t\tconfigurable: true,\n\t\t\t\t// eslint-disable-next-line getter-return\n\t\t\t\tget: () => {\n\t\t\t\t\tif (value !== undefined) {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\n\t\t\t\t\te.rune_outside_svelte(rune);\n\t\t\t\t},\n\t\t\t\tset: (v) => {\n\t\t\t\t\tvalue = v;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tthrow_rune_error('$state');\n\tthrow_rune_error('$effect');\n\tthrow_rune_error('$derived');\n\tthrow_rune_error('$inspect');\n\tthrow_rune_error('$props');\n\tthrow_rune_error('$bindable');\n}\n","const ATTR_REGEX = /[&\"<]/g;\nconst CONTENT_REGEX = /[&<]/g;\n\n/**\n * @template V\n * @param {V} value\n * @param {boolean} [is_attr]\n */\nexport function escape_html(value, is_attr) {\n\tconst str = String(value ?? '');\n\n\tconst pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;\n\tpattern.lastIndex = 0;\n\n\tlet escaped = '';\n\tlet last = 0;\n\n\twhile (pattern.test(str)) {\n\t\tconst i = pattern.lastIndex - 1;\n\t\tconst ch = str[i];\n\t\tescaped += str.substring(last, i) + (ch === '&' ? '&amp;' : ch === '\"' ? '&quot;' : '&lt;');\n\t\tlast = i + 1;\n\t}\n\n\treturn escaped + str.substring(last);\n}\n","const regex_return_characters = /\\r/g;\n\n/**\n * @param {string} str\n * @returns {string}\n */\nexport function hash(str) {\n\tstr = str.replace(regex_return_characters, '');\n\tlet hash = 5381;\n\tlet i = str.length;\n\n\twhile (i--) hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n\treturn (hash >>> 0).toString(36);\n}\n\nconst VOID_ELEMENT_NAMES = [\n\t'area',\n\t'base',\n\t'br',\n\t'col',\n\t'command',\n\t'embed',\n\t'hr',\n\t'img',\n\t'input',\n\t'keygen',\n\t'link',\n\t'meta',\n\t'param',\n\t'source',\n\t'track',\n\t'wbr'\n];\n\n/**\n * Returns `true` if `name` is of a void element\n * @param {string} name\n */\nexport function is_void(name) {\n\treturn VOID_ELEMENT_NAMES.includes(name) || name.toLowerCase() === '!doctype';\n}\n\nconst RESERVED_WORDS = [\n\t'arguments',\n\t'await',\n\t'break',\n\t'case',\n\t'catch',\n\t'class',\n\t'const',\n\t'continue',\n\t'debugger',\n\t'default',\n\t'delete',\n\t'do',\n\t'else',\n\t'enum',\n\t'eval',\n\t'export',\n\t'extends',\n\t'false',\n\t'finally',\n\t'for',\n\t'function',\n\t'if',\n\t'implements',\n\t'import',\n\t'in',\n\t'instanceof',\n\t'interface',\n\t'let',\n\t'new',\n\t'null',\n\t'package',\n\t'private',\n\t'protected',\n\t'public',\n\t'return',\n\t'static',\n\t'super',\n\t'switch',\n\t'this',\n\t'throw',\n\t'true',\n\t'try',\n\t'typeof',\n\t'var',\n\t'void',\n\t'while',\n\t'with',\n\t'yield'\n];\n\n/**\n * Returns `true` if `word` is a reserved JavaScript keyword\n * @param {string} word\n */\nexport function is_reserved(word) {\n\treturn RESERVED_WORDS.includes(word);\n}\n\n/**\n * @param {string} name\n */\nexport function is_capture_event(name) {\n\treturn name.endsWith('capture') && name !== 'gotpointercapture' && name !== 'lostpointercapture';\n}\n\n/** List of Element events that will be delegated */\nconst DELEGATED_EVENTS = [\n\t'beforeinput',\n\t'click',\n\t'change',\n\t'dblclick',\n\t'contextmenu',\n\t'focusin',\n\t'focusout',\n\t'input',\n\t'keydown',\n\t'keyup',\n\t'mousedown',\n\t'mousemove',\n\t'mouseout',\n\t'mouseover',\n\t'mouseup',\n\t'pointerdown',\n\t'pointermove',\n\t'pointerout',\n\t'pointerover',\n\t'pointerup',\n\t'touchend',\n\t'touchmove',\n\t'touchstart'\n];\n\n/**\n * Returns `true` if `event_name` is a delegated event\n * @param {string} event_name\n */\nexport function is_delegated(event_name) {\n\treturn DELEGATED_EVENTS.includes(event_name);\n}\n\n/**\n * Attributes that are boolean, i.e. they are present or not present.\n */\nconst DOM_BOOLEAN_ATTRIBUTES = [\n\t'allowfullscreen',\n\t'async',\n\t'autofocus',\n\t'autoplay',\n\t'checked',\n\t'controls',\n\t'default',\n\t'disabled',\n\t'formnovalidate',\n\t'hidden',\n\t'indeterminate',\n\t'ismap',\n\t'loop',\n\t'multiple',\n\t'muted',\n\t'nomodule',\n\t'novalidate',\n\t'open',\n\t'playsinline',\n\t'readonly',\n\t'required',\n\t'reversed',\n\t'seamless',\n\t'selected',\n\t'webkitdirectory'\n];\n\n/**\n * Returns `true` if `name` is a boolean attribute\n * @param {string} name\n */\nexport function is_boolean_attribute(name) {\n\treturn DOM_BOOLEAN_ATTRIBUTES.includes(name);\n}\n\n/**\n * @type {Record<string, string>}\n * List of attribute names that should be aliased to their property names\n * because they behave differently between setting them as an attribute and\n * setting them as a property.\n */\nconst ATTRIBUTE_ALIASES = {\n\t// no `class: 'className'` because we handle that separately\n\tformnovalidate: 'formNoValidate',\n\tismap: 'isMap',\n\tnomodule: 'noModule',\n\tplaysinline: 'playsInline',\n\treadonly: 'readOnly'\n};\n\n/**\n * @param {string} name\n */\nexport function normalize_attribute(name) {\n\tname = name.toLowerCase();\n\treturn ATTRIBUTE_ALIASES[name] ?? name;\n}\n\nconst DOM_PROPERTIES = [\n\t...DOM_BOOLEAN_ATTRIBUTES,\n\t'formNoValidate',\n\t'isMap',\n\t'noModule',\n\t'playsInline',\n\t'readOnly',\n\t'value',\n\t'inert',\n\t'volume'\n];\n\n/**\n * @param {string} name\n */\nexport function is_dom_property(name) {\n\treturn DOM_PROPERTIES.includes(name);\n}\n\n/**\n * Subset of delegated events which should be passive by default.\n * These two are already passive via browser defaults on window, document and body.\n * But since\n * - we're delegating them\n * - they happen often\n * - they apply to mobile which is generally less performant\n * we're marking them as passive by default for other elements, too.\n */\nconst PASSIVE_EVENTS = ['touchstart', 'touchmove'];\n\n/**\n * Returns `true` if `name` is a passive event\n * @param {string} name\n */\nexport function is_passive_event(name) {\n\treturn PASSIVE_EVENTS.includes(name);\n}\n\nconst CONTENT_EDITABLE_BINDINGS = ['textContent', 'innerHTML', 'innerText'];\n\n/** @param {string} name */\nexport function is_content_editable_binding(name) {\n\treturn CONTENT_EDITABLE_BINDINGS.includes(name);\n}\n\nconst LOAD_ERROR_ELEMENTS = [\n\t'body',\n\t'embed',\n\t'iframe',\n\t'img',\n\t'link',\n\t'object',\n\t'script',\n\t'style',\n\t'track'\n];\n\n/**\n * Returns `true` if the element emits `load` and `error` events\n * @param {string} name\n */\nexport function is_load_error_element(name) {\n\treturn LOAD_ERROR_ELEMENTS.includes(name);\n}\n\nconst SVG_ELEMENTS = [\n\t'altGlyph',\n\t'altGlyphDef',\n\t'altGlyphItem',\n\t'animate',\n\t'animateColor',\n\t'animateMotion',\n\t'animateTransform',\n\t'circle',\n\t'clipPath',\n\t'color-profile',\n\t'cursor',\n\t'defs',\n\t'desc',\n\t'discard',\n\t'ellipse',\n\t'feBlend',\n\t'feColorMatrix',\n\t'feComponentTransfer',\n\t'feComposite',\n\t'feConvolveMatrix',\n\t'feDiffuseLighting',\n\t'feDisplacementMap',\n\t'feDistantLight',\n\t'feDropShadow',\n\t'feFlood',\n\t'feFuncA',\n\t'feFuncB',\n\t'feFuncG',\n\t'feFuncR',\n\t'feGaussianBlur',\n\t'feImage',\n\t'feMerge',\n\t'feMergeNode',\n\t'feMorphology',\n\t'feOffset',\n\t'fePointLight',\n\t'feSpecularLighting',\n\t'feSpotLight',\n\t'feTile',\n\t'feTurbulence',\n\t'filter',\n\t'font',\n\t'font-face',\n\t'font-face-format',\n\t'font-face-name',\n\t'font-face-src',\n\t'font-face-uri',\n\t'foreignObject',\n\t'g',\n\t'glyph',\n\t'glyphRef',\n\t'hatch',\n\t'hatchpath',\n\t'hkern',\n\t'image',\n\t'line',\n\t'linearGradient',\n\t'marker',\n\t'mask',\n\t'mesh',\n\t'meshgradient',\n\t'meshpatch',\n\t'meshrow',\n\t'metadata',\n\t'missing-glyph',\n\t'mpath',\n\t'path',\n\t'pattern',\n\t'polygon',\n\t'polyline',\n\t'radialGradient',\n\t'rect',\n\t'set',\n\t'solidcolor',\n\t'stop',\n\t'svg',\n\t'switch',\n\t'symbol',\n\t'text',\n\t'textPath',\n\t'tref',\n\t'tspan',\n\t'unknown',\n\t'use',\n\t'view',\n\t'vkern'\n];\n\n/** @param {string} name */\nexport function is_svg(name) {\n\treturn SVG_ELEMENTS.includes(name);\n}\n\nconst MATHML_ELEMENTS = [\n\t'annotation',\n\t'annotation-xml',\n\t'maction',\n\t'math',\n\t'merror',\n\t'mfrac',\n\t'mi',\n\t'mmultiscripts',\n\t'mn',\n\t'mo',\n\t'mover',\n\t'mpadded',\n\t'mphantom',\n\t'mprescripts',\n\t'mroot',\n\t'mrow',\n\t'ms',\n\t'mspace',\n\t'msqrt',\n\t'mstyle',\n\t'msub',\n\t'msubsup',\n\t'msup',\n\t'mtable',\n\t'mtd',\n\t'mtext',\n\t'mtr',\n\t'munder',\n\t'munderover',\n\t'semantics'\n];\n\n/** @param {string} name */\nexport function is_mathml(name) {\n\treturn MATHML_ELEMENTS.includes(name);\n}\n\nconst RUNES = /** @type {const} */ ([\n\t'$state',\n\t'$state.raw',\n\t'$state.snapshot',\n\t'$props',\n\t'$bindable',\n\t'$derived',\n\t'$derived.by',\n\t'$effect',\n\t'$effect.pre',\n\t'$effect.tracking',\n\t'$effect.root',\n\t'$inspect',\n\t'$inspect().with',\n\t'$host'\n]);\n\n/**\n * @param {string} name\n * @returns {name is RUNES[number]}\n */\nexport function is_rune(name) {\n\treturn RUNES.includes(/** @type {RUNES[number]} */ (name));\n}\n","import { escape_html } from '../../escaping.js';\n\n/**\n * `<div translate={false}>` should be rendered as `<div translate=\"no\">` and _not_\n * `<div translate=\"false\">`, which is equivalent to `<div translate=\"yes\">`. There\n * may be other odd cases that need to be added to this list in future\n * @type {Record<string, Map<any, string>>}\n */\nconst replacements = {\n\ttranslate: new Map([\n\t\t[true, 'yes'],\n\t\t[false, 'no']\n\t])\n};\n\n/**\n * @template V\n * @param {string} name\n * @param {V} value\n * @param {boolean} [is_boolean]\n * @returns {string}\n */\nexport function attr(name, value, is_boolean = false) {\n\tif (value == null || (!value && is_boolean) || (value === '' && name === 'class')) return '';\n\tconst normalized = (name in replacements && replacements[name].get(value)) || value;\n\tconst assignment = is_boolean ? '' : `=\"${escape_html(normalized, true)}\"`;\n\treturn ` ${name}${assignment}`;\n}\n","/** @import { Readable } from './public' */\nimport { untrack } from '../index-client.js';\nimport { noop } from '../internal/shared/utils.js';\n\n/**\n * @template T\n * @param {Readable<T> | null | undefined} store\n * @param {(value: T) => void} run\n * @param {(value: T) => void} [invalidate]\n * @returns {() => void}\n */\nexport function subscribe_to_store(store, run, invalidate) {\n\tif (store == null) {\n\t\t// @ts-expect-error\n\t\trun(undefined);\n\n\t\t// @ts-expect-error\n\t\tif (invalidate) invalidate(undefined);\n\n\t\treturn noop;\n\t}\n\n\t// Svelte store takes a private second argument\n\t// StartStopNotifier could mutate state, and we want to silence the corresponding validation error\n\tconst unsub = untrack(() =>\n\t\tstore.subscribe(\n\t\t\trun,\n\t\t\t// @ts-expect-error\n\t\t\tinvalidate\n\t\t)\n\t);\n\n\t// Also support RxJS\n\t// @ts-expect-error TODO fix this in the types?\n\treturn unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\n","/** @import { Component } from '#server' */\nimport { DEV } from 'esm-env';\nimport { on_destroy } from './index.js';\nimport * as e from '../shared/errors.js';\n\n/** @type {Component | null} */\nexport var current_component = null;\n\n/**\n * @template T\n * @param {any} key\n * @returns {T}\n */\nexport function getContext(key) {\n\tconst context_map = get_or_init_context_map('getContext');\n\tconst result = /** @type {T} */ (context_map.get(key));\n\n\treturn result;\n}\n\n/**\n * @template T\n * @param {any} key\n * @param {T} context\n * @returns {T}\n */\nexport function setContext(key, context) {\n\tget_or_init_context_map('setContext').set(key, context);\n\treturn context;\n}\n\n/**\n * @param {any} key\n * @returns {boolean}\n */\nexport function hasContext(key) {\n\treturn get_or_init_context_map('hasContext').has(key);\n}\n\n/** @returns {Map<any, any>} */\nexport function getAllContexts() {\n\treturn get_or_init_context_map('getAllContexts');\n}\n\n/**\n * @param {string} name\n * @returns {Map<unknown, unknown>}\n */\nfunction get_or_init_context_map(name) {\n\tif (current_component === null) {\n\t\te.lifecycle_outside_component(name);\n\t}\n\n\treturn (current_component.c ??= new Map(get_parent_context(current_component) || undefined));\n}\n\n/**\n * @param {Function} [fn]\n */\nexport function push(fn) {\n\tcurrent_component = { p: current_component, c: null, d: null };\n\tif (DEV) {\n\t\t// component function\n\t\tcurrent_component.function = fn;\n\t}\n}\n\nexport function pop() {\n\tvar component = /** @type {Component} */ (current_component);\n\n\tvar ondestroy = component.d;\n\n\tif (ondestroy) {\n\t\ton_destroy.push(...ondestroy);\n\t}\n\n\tcurrent_component = component.p;\n}\n\n/**\n * @param {Component} component_context\n * @returns {Map<unknown, unknown> | null}\n */\nfunction get_parent_context(component_context) {\n\tlet parent = component_context.p;\n\n\twhile (parent !== null) {\n\t\tconst context_map = parent.c;\n\t\tif (context_map !== null) {\n\t\t\treturn context_map;\n\t\t}\n\t\tparent = parent.p;\n\t}\n\n\treturn null;\n}\n","import { HYDRATION_END, HYDRATION_START, HYDRATION_START_ELSE } from '../../constants.js';\n\nexport const BLOCK_OPEN = `<!--${HYDRATION_START}-->`;\nexport const BLOCK_OPEN_ELSE = `<!--${HYDRATION_START_ELSE}-->`;\nexport const BLOCK_CLOSE = `<!--${HYDRATION_END}-->`;\nexport const EMPTY_COMMENT = `<!---->`;\n","/** @import { ComponentType, SvelteComponent } from 'svelte' */\n/** @import { Component, Payload, RenderOutput } from '#server' */\n/** @import { Store } from '#shared' */\nexport { FILENAME, HMR } from '../../constants.js';\nimport { attr } from '../shared/attributes.js';\nimport { is_promise, noop } from '../shared/utils.js';\nimport { subscribe_to_store } from '../../store/utils.js';\nimport {\n\tUNINITIALIZED,\n\tELEMENT_PRESERVE_ATTRIBUTE_CASE,\n\tELEMENT_IS_NAMESPACED\n} from '../../constants.js';\n\nimport { escape_html } from '../../escaping.js';\nimport { DEV } from 'esm-env';\nimport { current_component, pop, push } from './context.js';\nimport { EMPTY_COMMENT, BLOCK_CLOSE, BLOCK_OPEN } from './hydration.js';\nimport { validate_store } from '../shared/validate.js';\nimport { is_boolean_attribute, is_void } from '../../utils.js';\nimport { reset_elements } from './dev.js';\n\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nconst INVALID_ATTR_NAME_CHAR_REGEX =\n\t/[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n\n/** List of elements that require raw contents and should not have SSR comments put in them */\nconst RAW_TEXT_ELEMENTS = ['textarea', 'script', 'style', 'title'];\n\n/**\n * @param {Payload} to_copy\n * @returns {Payload}\n */\nexport function copy_payload({ out, css, head }) {\n\treturn {\n\t\tout,\n\t\tcss: new Set(css),\n\t\thead: {\n\t\t\ttitle: head.title,\n\t\t\tout: head.out\n\t\t}\n\t};\n}\n\n/**\n * Assigns second payload to first\n * @param {Payload} p1\n * @param {Payload} p2\n * @returns {void}\n */\nexport function assign_payload(p1, p2) {\n\tp1.out = p2.out;\n\tp1.head = p2.head;\n}\n\n/**\n * @param {Payload} payload\n * @param {string} tag\n * @param {() => void} attributes_fn\n * @param {() => void} children_fn\n * @returns {void}\n */\nexport function element(payload, tag, attributes_fn = noop, children_fn = noop) {\n\tpayload.out += '<!---->';\n\n\tif (tag) {\n\t\tpayload.out += `<${tag} `;\n\t\tattributes_fn();\n\t\tpayload.out += `>`;\n\n\t\tif (!is_void(tag)) {\n\t\t\tchildren_fn();\n\t\t\tif (!RAW_TEXT_ELEMENTS.includes(tag)) {\n\t\t\t\tpayload.out += EMPTY_COMMENT;\n\t\t\t}\n\t\t\tpayload.out += `</${tag}>`;\n\t\t}\n\t}\n\n\tpayload.out += '<!---->';\n}\n\n/**\n * Array of `onDestroy` callbacks that should be called at the end of the server render function\n * @type {Function[]}\n */\nexport let on_destroy = [];\n\n/**\n * Only available on the server and when compiling with the `server` option.\n * Takes a component and returns an object with `body` and `head` properties on it, which you can use to populate the HTML when server-rendering your app.\n * @template {Record<string, any>} Props\n * @param {import('svelte').Component<Props> | ComponentType<SvelteComponent<Props>>} component\n * @param {{ props?: Omit<Props, '$$slots' | '$$events'>; context?: Map<any, any> }} [options]\n * @returns {RenderOutput}\n */\nexport function render(component, options = {}) {\n\t/** @type {Payload} */\n\tconst payload = { out: '', css: new Set(), head: { title: '', out: '' } };\n\n\tconst prev_on_destroy = on_destroy;\n\ton_destroy = [];\n\tpayload.out += BLOCK_OPEN;\n\n\tlet reset_reset_element;\n\n\tif (DEV) {\n\t\t// prevent parent/child element state being corrupted by a bad render\n\t\treset_reset_element = reset_elements();\n\t}\n\n\tif (options.context) {\n\t\tpush();\n\t\t/** @type {Component} */ (current_component).c = options.context;\n\t}\n\n\t// @ts-expect-error\n\tcomponent(payload, options.props ?? {}, {}, {});\n\n\tif (options.context) {\n\t\tpop();\n\t}\n\n\tif (reset_reset_element) {\n\t\treset_reset_element();\n\t}\n\n\tpayload.out += BLOCK_CLOSE;\n\tfor (const cleanup of on_destroy) cleanup();\n\ton_destroy = prev_on_destroy;\n\n\tlet head = payload.head.out + payload.head.title;\n\n\tfor (const { hash, code } of payload.css) {\n\t\thead += `<style id=\"${hash}\">${code}</style>`;\n\t}\n\n\treturn {\n\t\thead,\n\t\thtml: payload.out,\n\t\tbody: payload.out\n\t};\n}\n\n/**\n * @param {Payload} payload\n * @param {(head_payload: Payload['head']) => void} fn\n * @returns {void}\n */\nexport function head(payload, fn) {\n\tconst head_payload = payload.head;\n\thead_payload.out += BLOCK_OPEN;\n\tfn(head_payload);\n\thead_payload.out += BLOCK_CLOSE;\n}\n\n/**\n * @param {Payload} payload\n * @param {boolean} is_html\n * @param {Record<string, string>} props\n * @param {() => void} component\n * @param {boolean} dynamic\n * @returns {void}\n */\nexport function css_props(payload, is_html, props, component, dynamic = false) {\n\tconst styles = style_object_to_string(props);\n\n\tif (is_html) {\n\t\tpayload.out += `<svelte-css-wrapper style=\"display: contents; ${styles}\">`;\n\t} else {\n\t\tpayload.out += `<g style=\"${styles}\">`;\n\t}\n\n\tif (dynamic) {\n\t\tpayload.out += '<!---->';\n\t}\n\n\tcomponent();\n\n\tif (is_html) {\n\t\tpayload.out += `<!----></svelte-css-wrapper>`;\n\t} else {\n\t\tpayload.out += `<!----></g>`;\n\t}\n}\n\n/**\n * @param {Record<string, unknown>} attrs\n * @param {Record<string, string>} [classes]\n * @param {Record<string, string>} [styles]\n * @param {number} [flags]\n * @returns {string}\n */\nexport function spread_attributes(attrs, classes, styles, flags = 0) {\n\tif (styles) {\n\t\tattrs.style = attrs.style\n\t\t\t? style_object_to_string(merge_styles(/** @type {string} */ (attrs.style), styles))\n\t\t\t: style_object_to_string(styles);\n\t}\n\n\tif (classes) {\n\t\tconst classlist = attrs.class ? [attrs.class] : [];\n\n\t\tfor (const key in classes) {\n\t\t\tif (classes[key]) {\n\t\t\t\tclasslist.push(key);\n\t\t\t}\n\t\t}\n\n\t\tattrs.class = classlist.join(' ');\n\t}\n\n\tlet attr_str = '';\n\tlet name;\n\n\tconst is_html = (flags & ELEMENT_IS_NAMESPACED) === 0;\n\tconst lowercase = (flags & ELEMENT_PRESERVE_ATTRIBUTE_CASE) === 0;\n\n\tfor (name in attrs) {\n\t\t// omit functions, internal svelte properties and invalid attribute names\n\t\tif (typeof attrs[name] === 'function') continue;\n\t\tif (name[0] === '$' && name[1] === '$') continue; // faster than name.startsWith('$$')\n\t\tif (INVALID_ATTR_NAME_CHAR_REGEX.test(name)) continue;\n\n\t\tif (lowercase) {\n\t\t\tname = name.toLowerCase();\n\t\t}\n\n\t\tattr_str += attr(name, attrs[name], is_html && is_boolean_attribute(name));\n\t}\n\n\treturn attr_str;\n}\n\n/**\n * @param {Record<string, unknown>[]} props\n * @returns {Record<string, unknown>}\n */\nexport function spread_props(props) {\n\t/** @type {Record<string, unknown>} */\n\tconst merged_props = {};\n\tlet key;\n\n\tfor (let i = 0; i < props.length; i++) {\n\t\tconst obj = props[i];\n\t\tfor (key in obj) {\n\t\t\tconst desc = Object.getOwnPropertyDescriptor(obj, key);\n\t\t\tif (desc) {\n\t\t\t\tObject.defineProperty(merged_props, key, desc);\n\t\t\t} else {\n\t\t\t\tmerged_props[key] = obj[key];\n\t\t\t}\n\t\t}\n\t}\n\treturn merged_props;\n}\n\n/**\n * @param {unknown} value\n * @returns {string}\n */\nexport function stringify(value) {\n\treturn typeof value === 'string' ? value : value == null ? '' : value + '';\n}\n\n/** @param {Record<string, string>} style_object */\nfunction style_object_to_string(style_object) {\n\treturn Object.keys(style_object)\n\t\t.filter(/** @param {any} key */ (key) => style_object[key] != null && style_object[key] !== '')\n\t\t.map(/** @param {any} key */ (key) => `${key}: ${escape_html(style_object[key], true)};`)\n\t\t.join(' ');\n}\n\n/** @param {Record<string, string>} style_object */\nexport function add_styles(style_object) {\n\tconst styles = style_object_to_string(style_object);\n\treturn styles ? ` style=\"${styles}\"` : '';\n}\n\n/**\n * @param {string} attribute\n * @param {Record<string, string>} styles\n */\nexport function merge_styles(attribute, styles) {\n\t/** @type {Record<string, string>} */\n\tvar merged = {};\n\n\tif (attribute) {\n\t\tfor (var declaration of attribute.split(';')) {\n\t\t\tvar i = declaration.indexOf(':');\n\t\t\tvar name = declaration.slice(0, i).trim();\n\t\t\tvar value = declaration.slice(i + 1).trim();\n\n\t\t\tif (name !== '') merged[name] = value;\n\t\t}\n\t}\n\n\tfor (name in styles) {\n\t\tmerged[name] = styles[name];\n\t}\n\n\treturn merged;\n}\n\n/**\n * @template V\n * @param {Record<string, [any, any, any]>} store_values\n * @param {string} store_name\n * @param {Store<V> | null | undefined} store\n * @returns {V}\n */\nexport function store_get(store_values, store_name, store) {\n\tif (DEV) {\n\t\tvalidate_store(store, store_name.slice(1));\n\t}\n\n\t// it could be that someone eagerly updates the store in the instance script, so\n\t// we should only reuse the store value in the template\n\tif (store_name in store_values && store_values[store_name][0] === store) {\n\t\treturn store_values[store_name][2];\n\t}\n\n\tstore_values[store_name]?.[1](); // if store was switched, unsubscribe from old store\n\tstore_values[store_name] = [store, null, undefined];\n\tconst unsub = subscribe_to_store(\n\t\tstore,\n\t\t/** @param {any} v */ (v) => (store_values[store_name][2] = v)\n\t);\n\tstore_values[store_name][1] = unsub;\n\treturn store_values[store_name][2];\n}\n\n/**\n * Sets the new value of a store and returns that value.\n * @template V\n * @param {Store<V>} store\n * @param {V} value\n * @returns {V}\n */\nexport function store_set(store, value) {\n\tstore.set(value);\n\treturn value;\n}\n\n/**\n * Updates a store with a new value.\n * @template V\n * @param {Record<string, [any, any, any]>} store_values\n * @param {string} store_name\n * @param {Store<V>} store\n * @param {any} expression\n */\nexport function store_mutate(store_values, store_name, store, expression) {\n\tstore_set(store, store_get(store_values, store_name, store));\n\treturn expression;\n}\n\n/**\n * @param {Record<string, [any, any, any]>} store_values\n * @param {string} store_name\n * @param {Store<number>} store\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_store(store_values, store_name, store, d = 1) {\n\tlet store_value = store_get(store_values, store_name, store);\n\tstore.set(store_value + d);\n\treturn store_value;\n}\n\n/**\n * @param {Record<string, [any, any, any]>} store_values\n * @param {string} store_name\n * @param {Store<number>} store\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_store_pre(store_values, store_name, store, d = 1) {\n\tconst value = store_get(store_values, store_name, store) + d;\n\tstore.set(value);\n\treturn value;\n}\n\n/** @param {Record<string, [any, any, any]>} store_values */\nexport function unsubscribe_stores(store_values) {\n\tfor (const store_name in store_values) {\n\t\tstore_values[store_name][1]();\n\t}\n}\n\n/**\n * @param {Payload} payload\n * @param {Record<string, any>} $$props\n * @param {string} name\n * @param {Record<string, unknown>} slot_props\n * @param {null | (() => void)} fallback_fn\n * @returns {void}\n */\nexport function slot(payload, $$props, name, slot_props, fallback_fn) {\n\tvar slot_fn = $$props.$$slots?.[name];\n\t// Interop: Can use snippets to fill slots\n\tif (slot_fn === true) {\n\t\tslot_fn = $$props[name === 'default' ? 'children' : name];\n\t}\n\n\tif (slot_fn !== undefined) {\n\t\tslot_fn(payload, slot_props);\n\t} else {\n\t\tfallback_fn?.();\n\t}\n}\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} rest\n * @returns {Record<string, unknown>}\n */\nexport function rest_props(props, rest) {\n\t/** @type {Record<string, unknown>} */\n\tconst rest_props = {};\n\tlet key;\n\tfor (key in props) {\n\t\tif (!rest.includes(key)) {\n\t\t\trest_props[key] = props[key];\n\t\t}\n\t}\n\treturn rest_props;\n}\n\n/**\n * @param {Record<string, unknown>} props\n * @returns {Record<string, unknown>}\n */\nexport function sanitize_props(props) {\n\tconst { children, $$slots, ...sanitized } = props;\n\treturn sanitized;\n}\n\n/**\n * @param {Record<string, any>} props\n * @returns {Record<string, boolean>}\n */\nexport function sanitize_slots(props) {\n\t/** @type {Record<string, boolean>} */\n\tconst sanitized = {};\n\tif (props.children) sanitized.default = true;\n\tfor (const key in props.$$slots) {\n\t\tsanitized[key] = true;\n\t}\n\treturn sanitized;\n}\n\n/**\n * Legacy mode: If the prop has a fallback and is bound in the\n * parent component, propagate the fallback value upwards.\n * @param {Record<string, unknown>} props_parent\n * @param {Record<string, unknown>} props_now\n */\nexport function bind_props(props_parent, props_now) {\n\tfor (const key in props_now) {\n\t\tconst initial_value = props_parent[key];\n\t\tconst value = props_now[key];\n\t\tif (\n\t\t\tinitial_value === undefined &&\n\t\t\tvalue !== undefined &&\n\t\t\tObject.getOwnPropertyDescriptor(props_parent, key)?.set\n\t\t) {\n\t\t\tprops_parent[key] = value;\n\t\t}\n\t}\n}\n\n/**\n * @template V\n * @param {Promise<V>} promise\n * @param {null | (() => void)} pending_fn\n * @param {(value: V) => void} then_fn\n * @returns {void}\n */\nfunction await_block(promise, pending_fn, then_fn) {\n\tif (is_promise(promise)) {\n\t\tpromise.then(null, noop);\n\t\tif (pending_fn !== null) {\n\t\t\tpending_fn();\n\t\t}\n\t} else if (then_fn !== null) {\n\t\tthen_fn(promise);\n\t}\n}\n\nexport { await_block as await };\n\n/** @param {any} array_like_or_iterator */\nexport function ensure_array_like(array_like_or_iterator) {\n\tif (array_like_or_iterator) {\n\t\treturn array_like_or_iterator.length !== undefined\n\t\t\t? array_like_or_iterator\n\t\t\t: Array.from(array_like_or_iterator);\n\t}\n\treturn [];\n}\n\n/**\n * @param {any[]} args\n * @param {Function} [inspect]\n */\n// eslint-disable-next-line no-console\nexport function inspect(args, inspect = console.log) {\n\tinspect('init', ...args);\n}\n\n/**\n * @template V\n * @param {() => V} get_value\n */\nexport function once(get_value) {\n\tlet value = /** @type {V} */ (UNINITIALIZED);\n\treturn () => {\n\t\tif (value === UNINITIALIZED) {\n\t\t\tvalue = get_value();\n\t\t}\n\t\treturn value;\n\t};\n}\n\nexport { attr };\n\nexport { html } from './blocks/html.js';\n\nexport { push, pop } from './context.js';\n\nexport { push_element, pop_element } from './dev.js';\n\nexport { snapshot } from '../shared/clone.js';\n\nexport { fallback } from '../shared/utils.js';\n\nexport {\n\tinvalid_default_snippet,\n\tvalidate_dynamic_element_tag,\n\tvalidate_void_dynamic_element\n} from '../shared/validate.js';\n\nexport { escape_html as escape };\n"],"names":["fallback","effect","push","component_context","e.effect_update_depth_exceeded","e.state_unsafe_local_read","pop","e.lifecycle_outside_component","rest_props"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18]}